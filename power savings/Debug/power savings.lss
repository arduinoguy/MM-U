
power savings.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000044  00800100  000019b6  00001a4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000019b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000115  00800144  00800144  00001a8e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001a8e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004f0  00000000  00000000  00001abe  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000b557  00000000  00000000  00001fae  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000021df  00000000  00000000  0000d505  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001c39  00000000  00000000  0000f6e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000010a8  00000000  00000000  00011320  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002684  00000000  00000000  000123c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005084  00000000  00000000  00014a4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005b0  00000000  00000000  00019ad0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1c 01 	jmp	0x238	; 0x238 <__ctors_end>
       4:	0c 94 3e 0a 	jmp	0x147c	; 0x147c <__vector_1>
       8:	0c 94 6b 0a 	jmp	0x14d6	; 0x14d6 <__vector_2>
       c:	0c 94 98 0a 	jmp	0x1530	; 0x1530 <__vector_3>
      10:	0c 94 c5 0a 	jmp	0x158a	; 0x158a <__vector_4>
      14:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      18:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      1c:	0c 94 f2 0a 	jmp	0x15e4	; 0x15e4 <__vector_7>
      20:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      24:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      28:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <__vector_10>
      2c:	0c 94 96 08 	jmp	0x112c	; 0x112c <__vector_11>
      30:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      34:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      38:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      3c:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      40:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      44:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      48:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      4c:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      50:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      54:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      58:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      5c:	0c 94 1f 0b 	jmp	0x163e	; 0x163e <__vector_23>
      60:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      64:	0c 94 49 03 	jmp	0x692	; 0x692 <__vector_25>
      68:	0c 94 84 03 	jmp	0x708	; 0x708 <__vector_26>
      6c:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      70:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      74:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      78:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      7c:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      80:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      84:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      88:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      8c:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      90:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      94:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      98:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      9c:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      a0:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      a4:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>
      a8:	0c 94 44 01 	jmp	0x288	; 0x288 <__bad_interrupt>

000000ac <__trampolines_end>:
      ac:	08 0b       	sbc	r16, r24
      ae:	00 02       	muls	r16, r16
      b0:	02 02       	muls	r16, r18
      b2:	01 00       	.word	0x0001	; ????
      b4:	09 04       	cpc	r0, r9
      b6:	00 00       	nop
      b8:	01 02       	muls	r16, r17
      ba:	02 00       	.word	0x0002	; ????
      bc:	00 05       	cpc	r16, r0
      be:	24 00       	.word	0x0024	; ????
      c0:	10 01       	movw	r2, r0
      c2:	05 24       	eor	r0, r5
      c4:	01 01       	movw	r0, r2
      c6:	01 04       	cpc	r0, r1
      c8:	24 02       	muls	r18, r20
      ca:	06 05       	cpc	r16, r6
      cc:	24 06       	cpc	r2, r20
      ce:	00 01       	movw	r0, r0
      d0:	07 05       	cpc	r16, r7
      d2:	81 03       	fmuls	r16, r17
      d4:	10 00       	.word	0x0010	; ????
      d6:	40 09       	sbc	r20, r0
      d8:	04 01       	movw	r0, r8
      da:	00 02       	muls	r16, r16
      dc:	0a 00       	.word	0x000a	; ????
      de:	00 00       	nop
      e0:	07 05       	cpc	r16, r7
      e2:	02 02       	muls	r16, r18
      e4:	40 00       	.word	0x0040	; ????
      e6:	00 07       	cpc	r16, r16
      e8:	05 83       	std	Z+5, r16	; 0x05
      ea:	02 40       	sbci	r16, 0x02	; 2
	...

000000ee <_asciimap>:
	...
      f6:	2a 2b 28 00 00 00 00 00 00 00 00 00 00 00 00 00     *+(.............
	...
     10e:	2c 9e b4 a0 a1 a2 a4 34 a6 a7 a5 ae 36 2d 37 38     ,......4....6-78
     11e:	27 1e 1f 20 21 22 23 24 25 26 b3 33 b6 2e b7 b8     '.. !"#$%&.3....
     12e:	9f 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92     ................
     13e:	93 94 95 96 97 98 99 9a 9b 9c 9d 2f 31 30 a3 ad     .........../10..
     14e:	35 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12     5...............
     15e:	13 14 15 16 17 18 19 1a 1b 1c 1d af b1 b0 b5 00     ................

0000016e <_hidInterface>:
     16e:	09 04 02 00 01 03 00 00 00 09 21 01 01 00 01 22     ..........!...."
     17e:	65 00 07 05 84 03 40 00 01                          e.....@..

00000187 <_hidReportDescriptor>:
     187:	05 01 09 02 a1 01 09 01 a1 00 85 01 05 09 19 01     ................
     197:	29 03 15 00 25 01 95 03 75 01 81 02 95 01 75 05     )...%...u.....u.
     1a7:	81 03 05 01 09 30 09 31 09 38 15 81 25 7f 75 08     .....0.1.8..%.u.
     1b7:	95 03 81 06 c0 c0 05 01 09 06 a1 01 85 02 05 07     ................
     1c7:	19 e0 29 e7 15 00 25 01 75 01 95 08 81 02 95 01     ..)...%.u.......
     1d7:	75 08 81 03 95 06 75 08 15 00 25 65 05 07 19 00     u.....u...%e....
     1e7:	29 65 81 00 c0                                      )e...

000001ec <_initEndpoints>:
     1ec:	00 c1 80 81 c1                                      .....

000001f1 <USB_DeviceDescriptorA>:
     1f1:	12 01 00 02 02 00 00 40 4f 1b 01 f1 00 01 01 02     .......@O.......
     201:	00 01                                               ..

00000203 <USB_DeviceDescriptor>:
     203:	12 01 00 02 00 00 00 40 4f 1b 01 f1 00 01 01 02     .......@O.......
     213:	00 01                                               ..

00000215 <STRING_MANUFACTURER>:
     215:	53 70 61 72 6b 46 75 6e 00                          SparkFun.

0000021e <STRING_PRODUCT>:
     21e:	55 53 42 20 49 4f 20 42 6f 61 72 64 00              USB IO Board.

0000022b <STRING_LANGUAGE>:
     22b:	04 03 09 04 00                                      .....

00000230 <__ctors_start>:
     230:	15 02       	muls	r17, r21
     232:	aa 03       	fmulsu	r18, r18
     234:	42 05       	cpc	r20, r2
     236:	92 05       	cpc	r25, r2

00000238 <__ctors_end>:
     238:	11 24       	eor	r1, r1
     23a:	1f be       	out	0x3f, r1	; 63
     23c:	cf ef       	ldi	r28, 0xFF	; 255
     23e:	d5 e0       	ldi	r29, 0x05	; 5
     240:	de bf       	out	0x3e, r29	; 62
     242:	cd bf       	out	0x3d, r28	; 61

00000244 <__do_copy_data>:
     244:	11 e0       	ldi	r17, 0x01	; 1
     246:	a0 e0       	ldi	r26, 0x00	; 0
     248:	b1 e0       	ldi	r27, 0x01	; 1
     24a:	e6 eb       	ldi	r30, 0xB6	; 182
     24c:	f9 e1       	ldi	r31, 0x19	; 25
     24e:	02 c0       	rjmp	.+4      	; 0x254 <__do_copy_data+0x10>
     250:	05 90       	lpm	r0, Z+
     252:	0d 92       	st	X+, r0
     254:	a4 34       	cpi	r26, 0x44	; 68
     256:	b1 07       	cpc	r27, r17
     258:	d9 f7       	brne	.-10     	; 0x250 <__do_copy_data+0xc>

0000025a <__do_clear_bss>:
     25a:	22 e0       	ldi	r18, 0x02	; 2
     25c:	a4 e4       	ldi	r26, 0x44	; 68
     25e:	b1 e0       	ldi	r27, 0x01	; 1
     260:	01 c0       	rjmp	.+2      	; 0x264 <.do_clear_bss_start>

00000262 <.do_clear_bss_loop>:
     262:	1d 92       	st	X+, r1

00000264 <.do_clear_bss_start>:
     264:	a9 35       	cpi	r26, 0x59	; 89
     266:	b2 07       	cpc	r27, r18
     268:	e1 f7       	brne	.-8      	; 0x262 <.do_clear_bss_loop>

0000026a <__do_global_ctors>:
     26a:	12 e0       	ldi	r17, 0x02	; 2
     26c:	c8 e3       	ldi	r28, 0x38	; 56
     26e:	d2 e0       	ldi	r29, 0x02	; 2
     270:	04 c0       	rjmp	.+8      	; 0x27a <__do_global_ctors+0x10>
     272:	22 97       	sbiw	r28, 0x02	; 2
     274:	fe 01       	movw	r30, r28
     276:	0e 94 bb 0c 	call	0x1976	; 0x1976 <__tablejump__>
     27a:	c0 33       	cpi	r28, 0x30	; 48
     27c:	d1 07       	cpc	r29, r17
     27e:	c9 f7       	brne	.-14     	; 0x272 <__do_global_ctors+0x8>
     280:	0e 94 4c 0c 	call	0x1898	; 0x1898 <main>
     284:	0c 94 d9 0c 	jmp	0x19b2	; 0x19b2 <_exit>

00000288 <__bad_interrupt>:
     288:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000028c <_ZN7Serial_5writeEh>:
{
	USB_Flush(CDC_TX);
}

size_t Serial_::write(uint8_t c)
{
     28c:	cf 93       	push	r28
     28e:	df 93       	push	r29
     290:	1f 92       	push	r1
     292:	cd b7       	in	r28, 0x3d	; 61
     294:	de b7       	in	r29, 0x3e	; 62
     296:	69 83       	std	Y+1, r22	; 0x01
	return write(&c, 1);
     298:	dc 01       	movw	r26, r24
     29a:	ed 91       	ld	r30, X+
     29c:	fc 91       	ld	r31, X
     29e:	02 80       	ldd	r0, Z+2	; 0x02
     2a0:	f3 81       	ldd	r31, Z+3	; 0x03
     2a2:	e0 2d       	mov	r30, r0
     2a4:	41 e0       	ldi	r20, 0x01	; 1
     2a6:	50 e0       	ldi	r21, 0x00	; 0
     2a8:	be 01       	movw	r22, r28
     2aa:	6f 5f       	subi	r22, 0xFF	; 255
     2ac:	7f 4f       	sbci	r23, 0xFF	; 255
     2ae:	09 95       	icall
}
     2b0:	0f 90       	pop	r0
     2b2:	df 91       	pop	r29
     2b4:	cf 91       	pop	r28
     2b6:	08 95       	ret

000002b8 <_ZN7Serial_9availableEv>:
{
}

int Serial_::available(void)
{
	if (peek_buffer >= 0) {
     2b8:	fc 01       	movw	r30, r24
     2ba:	84 85       	ldd	r24, Z+12	; 0x0c
     2bc:	95 85       	ldd	r25, Z+13	; 0x0d
     2be:	99 23       	and	r25, r25
     2c0:	34 f0       	brlt	.+12     	; 0x2ce <_ZN7Serial_9availableEv+0x16>
		return 1 + USB_Available(CDC_RX);
     2c2:	82 e0       	ldi	r24, 0x02	; 2
     2c4:	0e 94 0f 07 	call	0xe1e	; 0xe1e <_Z13USB_Availableh>
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	01 96       	adiw	r24, 0x01	; 1
     2cc:	08 95       	ret
	}
	return USB_Available(CDC_RX);
     2ce:	82 e0       	ldi	r24, 0x02	; 2
     2d0:	0e 94 0f 07 	call	0xe1e	; 0xe1e <_Z13USB_Availableh>
     2d4:	90 e0       	ldi	r25, 0x00	; 0
}
     2d6:	08 95       	ret

000002d8 <_ZN7Serial_4peekEv>:

int Serial_::peek(void)
{
     2d8:	cf 93       	push	r28
     2da:	df 93       	push	r29
     2dc:	ec 01       	movw	r28, r24
	if (peek_buffer < 0)
     2de:	8c 85       	ldd	r24, Y+12	; 0x0c
     2e0:	9d 85       	ldd	r25, Y+13	; 0x0d
     2e2:	99 23       	and	r25, r25
     2e4:	2c f4       	brge	.+10     	; 0x2f0 <_ZN7Serial_4peekEv+0x18>
		peek_buffer = USB_Recv(CDC_RX);
     2e6:	82 e0       	ldi	r24, 0x02	; 2
     2e8:	0e 94 4d 07 	call	0xe9a	; 0xe9a <_Z8USB_Recvh>
     2ec:	9d 87       	std	Y+13, r25	; 0x0d
     2ee:	8c 87       	std	Y+12, r24	; 0x0c
	return peek_buffer;
}
     2f0:	8c 85       	ldd	r24, Y+12	; 0x0c
     2f2:	9d 85       	ldd	r25, Y+13	; 0x0d
     2f4:	df 91       	pop	r29
     2f6:	cf 91       	pop	r28
     2f8:	08 95       	ret

000002fa <_ZN7Serial_4readEv>:

int Serial_::read(void)
{
     2fa:	fc 01       	movw	r30, r24
	if (peek_buffer >= 0) {
     2fc:	84 85       	ldd	r24, Z+12	; 0x0c
     2fe:	95 85       	ldd	r25, Z+13	; 0x0d
     300:	99 23       	and	r25, r25
     302:	2c f0       	brlt	.+10     	; 0x30e <_ZN7Serial_4readEv+0x14>
		int c = peek_buffer;
		peek_buffer = -1;
     304:	2f ef       	ldi	r18, 0xFF	; 255
     306:	3f ef       	ldi	r19, 0xFF	; 255
     308:	35 87       	std	Z+13, r19	; 0x0d
     30a:	24 87       	std	Z+12, r18	; 0x0c
		return c;
     30c:	08 95       	ret
	}
	return USB_Recv(CDC_RX);
     30e:	82 e0       	ldi	r24, 0x02	; 2
     310:	0e 94 4d 07 	call	0xe9a	; 0xe9a <_Z8USB_Recvh>
}
     314:	08 95       	ret

00000316 <_ZN7Serial_5flushEv>:

void Serial_::flush(void)
{
	USB_Flush(CDC_TX);
     316:	83 e0       	ldi	r24, 0x03	; 3
     318:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <_Z9USB_Flushh>
     31c:	08 95       	ret

0000031e <_ZN7Serial_5writeEPKhj>:
{
	return write(&c, 1);
}

size_t Serial_::write(const uint8_t *buffer, size_t size)
{
     31e:	cf 93       	push	r28
     320:	df 93       	push	r29
     322:	ec 01       	movw	r28, r24
	 the connection is closed are lost - just like with a UART. */
	
	// TODO - ZE - check behavior on different OSes and test what happens if an
	// open connection isn't broken cleanly (cable is yanked out, host dies
	// or locks up, or host virtual serial port hangs)
	if (_usbLineInfo.lineState > 0)	{
     324:	80 91 07 01 	lds	r24, 0x0107
     328:	88 23       	and	r24, r24
     32a:	81 f0       	breq	.+32     	; 0x34c <_ZN7Serial_5writeEPKhj+0x2e>
		int r = USB_Send(CDC_TX,buffer,size);
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	0e 94 75 07 	call	0xeea	; 0xeea <_Z8USB_SendhPKvi>
     332:	9c 01       	movw	r18, r24
		if (r > 0) {
     334:	18 16       	cp	r1, r24
     336:	19 06       	cpc	r1, r25
     338:	14 f4       	brge	.+4      	; 0x33e <_ZN7Serial_5writeEPKhj+0x20>
			return r;
     33a:	93 2f       	mov	r25, r19
     33c:	0d c0       	rjmp	.+26     	; 0x358 <_ZN7Serial_5writeEPKhj+0x3a>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	9b 83       	std	Y+3, r25	; 0x03
     344:	8a 83       	std	Y+2, r24	; 0x02
		} else {
			setWriteError();
			return 0;
     346:	80 e0       	ldi	r24, 0x00	; 0
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	06 c0       	rjmp	.+12     	; 0x358 <_ZN7Serial_5writeEPKhj+0x3a>
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	9b 83       	std	Y+3, r25	; 0x03
     352:	8a 83       	std	Y+2, r24	; 0x02
		}
	}
	setWriteError();
	return 0;
     354:	80 e0       	ldi	r24, 0x00	; 0
     356:	90 e0       	ldi	r25, 0x00	; 0
}
     358:	df 91       	pop	r29
     35a:	cf 91       	pop	r28
     35c:	08 95       	ret

0000035e <_Z16CDC_GetInterfacePh>:
	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
};

int WEAK CDC_GetInterface(u8* interfaceNum)
{
	interfaceNum[0] += 2;	// uses 2
     35e:	fc 01       	movw	r30, r24
     360:	20 81       	ld	r18, Z
     362:	2e 5f       	subi	r18, 0xFE	; 254
     364:	20 83       	st	Z, r18
	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
     366:	42 e4       	ldi	r20, 0x42	; 66
     368:	50 e0       	ldi	r21, 0x00	; 0
     36a:	6c ea       	ldi	r22, 0xAC	; 172
     36c:	70 e0       	ldi	r23, 0x00	; 0
     36e:	80 e8       	ldi	r24, 0x80	; 128
     370:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z15USB_SendControlhPKvi>
}
     374:	08 95       	ret

00000376 <_Z9CDC_SetupR5Setup>:

bool WEAK CDC_Setup(Setup& setup)
{
     376:	fc 01       	movw	r30, r24
	u8 r = setup.bRequest;
     378:	91 81       	ldd	r25, Z+1	; 0x01
	u8 requestType = setup.bmRequestType;
     37a:	80 81       	ld	r24, Z

	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
     37c:	81 3a       	cpi	r24, 0xA1	; 161
     37e:	59 f4       	brne	.+22     	; 0x396 <_Z9CDC_SetupR5Setup+0x20>
	{
		if (CDC_GET_LINE_CODING == r)
     380:	91 32       	cpi	r25, 0x21	; 33
     382:	59 f5       	brne	.+86     	; 0x3da <_Z9CDC_SetupR5Setup+0x64>
		{
			USB_SendControl(0,(void*)&_usbLineInfo,7);
     384:	47 e0       	ldi	r20, 0x07	; 7
     386:	50 e0       	ldi	r21, 0x00	; 0
     388:	60 e0       	ldi	r22, 0x00	; 0
     38a:	71 e0       	ldi	r23, 0x01	; 1
     38c:	80 e0       	ldi	r24, 0x00	; 0
     38e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z15USB_SendControlhPKvi>
			return true;
     392:	81 e0       	ldi	r24, 0x01	; 1
     394:	08 95       	ret
		}
	}

	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
     396:	81 32       	cpi	r24, 0x21	; 33
     398:	11 f5       	brne	.+68     	; 0x3de <_Z9CDC_SetupR5Setup+0x68>
	{
		if (CDC_SET_LINE_CODING == r)
     39a:	90 32       	cpi	r25, 0x20	; 32
     39c:	39 f4       	brne	.+14     	; 0x3ac <_Z9CDC_SetupR5Setup+0x36>
		{
			USB_RecvControl((void*)&_usbLineInfo,7);
     39e:	67 e0       	ldi	r22, 0x07	; 7
     3a0:	70 e0       	ldi	r23, 0x00	; 0
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	91 e0       	ldi	r25, 0x01	; 1
     3a6:	0e 94 6e 08 	call	0x10dc	; 0x10dc <_Z15USB_RecvControlPvi>
     3aa:	05 c0       	rjmp	.+10     	; 0x3b6 <_Z9CDC_SetupR5Setup+0x40>
		}

		if (CDC_SET_CONTROL_LINE_STATE == r)
     3ac:	92 32       	cpi	r25, 0x22	; 34
     3ae:	c9 f4       	brne	.+50     	; 0x3e2 <_Z9CDC_SetupR5Setup+0x6c>
		{
			_usbLineInfo.lineState = setup.wValueL;
     3b0:	82 81       	ldd	r24, Z+2	; 0x02
     3b2:	80 93 07 01 	sts	0x0107, r24
			// open at 1200 bps, is closed.  this is the signal to start the watchdog
			// with a relatively long period so it can finish housekeeping tasks
			// like servicing endpoints before the sketch ends

			// We check DTR state to determine if host port is open (bit 0 of lineState).
			if (1200 == _usbLineInfo.dwDTERate && (_usbLineInfo.lineState & 0x01) == 0)
     3b6:	80 91 00 01 	lds	r24, 0x0100
     3ba:	90 91 01 01 	lds	r25, 0x0101
     3be:	a0 91 02 01 	lds	r26, 0x0102
     3c2:	b0 91 03 01 	lds	r27, 0x0103
     3c6:	80 3b       	cpi	r24, 0xB0	; 176
     3c8:	94 40       	sbci	r25, 0x04	; 4
     3ca:	a1 05       	cpc	r26, r1
     3cc:	b1 05       	cpc	r27, r1
     3ce:	f1 f4       	brne	.+60     	; 0x40c <_Z9CDC_SetupR5Setup+0x96>
     3d0:	80 91 07 01 	lds	r24, 0x0107
     3d4:	80 ff       	sbrs	r24, 0
     3d6:	07 c0       	rjmp	.+14     	; 0x3e6 <_Z9CDC_SetupR5Setup+0x70>
     3d8:	19 c0       	rjmp	.+50     	; 0x40c <_Z9CDC_SetupR5Setup+0x96>
				*(uint16_t *)0x0800 = 0x0;
			}
		}
		return true;
	}
	return false;
     3da:	80 e0       	ldi	r24, 0x00	; 0
     3dc:	08 95       	ret
     3de:	80 e0       	ldi	r24, 0x00	; 0
     3e0:	08 95       	ret
				wdt_disable();
				wdt_reset();
				*(uint16_t *)0x0800 = 0x0;
			}
		}
		return true;
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	08 95       	ret
			// like servicing endpoints before the sketch ends

			// We check DTR state to determine if host port is open (bit 0 of lineState).
			if (1200 == _usbLineInfo.dwDTERate && (_usbLineInfo.lineState & 0x01) == 0)
			{
				*(uint16_t *)0x0800 = 0x7777;
     3e6:	87 e7       	ldi	r24, 0x77	; 119
     3e8:	97 e7       	ldi	r25, 0x77	; 119
     3ea:	90 93 01 08 	sts	0x0801, r25
     3ee:	80 93 00 08 	sts	0x0800, r24
				wdt_enable(WDTO_120MS);
     3f2:	2b e0       	ldi	r18, 0x0B	; 11
     3f4:	88 e1       	ldi	r24, 0x18	; 24
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	0f b6       	in	r0, 0x3f	; 63
     3fa:	f8 94       	cli
     3fc:	a8 95       	wdr
     3fe:	80 93 60 00 	sts	0x0060, r24
     402:	0f be       	out	0x3f, r0	; 63
     404:	20 93 60 00 	sts	0x0060, r18
				wdt_disable();
				wdt_reset();
				*(uint16_t *)0x0800 = 0x0;
			}
		}
		return true;
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	08 95       	ret
				// Most OSs do some intermediate steps when configuring ports and DTR can
				// twiggle more than once before stabilizing.
				// To avoid spurious resets we set the watchdog to 250ms and eventually
				// cancel if DTR goes back high.

				wdt_disable();
     40c:	88 e1       	ldi	r24, 0x18	; 24
     40e:	0f b6       	in	r0, 0x3f	; 63
     410:	f8 94       	cli
     412:	80 93 60 00 	sts	0x0060, r24
     416:	10 92 60 00 	sts	0x0060, r1
     41a:	0f be       	out	0x3f, r0	; 63
				wdt_reset();
     41c:	a8 95       	wdr
				*(uint16_t *)0x0800 = 0x0;
     41e:	10 92 01 08 	sts	0x0801, r1
     422:	10 92 00 08 	sts	0x0800, r1
			}
		}
		return true;
     426:	81 e0       	ldi	r24, 0x01	; 1
	}
	return false;
}
     428:	08 95       	ret

0000042a <_GLOBAL__sub_I__cdcInterface>:
  public:
    Print() : write_error(0) {}
     42a:	10 92 47 01 	sts	0x0147, r1
     42e:	10 92 46 01 	sts	0x0146, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     432:	88 ee       	ldi	r24, 0xE8	; 232
     434:	93 e0       	ldi	r25, 0x03	; 3
     436:	a0 e0       	ldi	r26, 0x00	; 0
     438:	b0 e0       	ldi	r27, 0x00	; 0
     43a:	80 93 48 01 	sts	0x0148, r24
     43e:	90 93 49 01 	sts	0x0149, r25
     442:	a0 93 4a 01 	sts	0x014A, r26
     446:	b0 93 4b 01 	sts	0x014B, r27
class Serial_ : public Stream
{
private:
	int peek_buffer;
public:
	Serial_() { peek_buffer = -1; };
     44a:	8e e0       	ldi	r24, 0x0E	; 14
     44c:	91 e0       	ldi	r25, 0x01	; 1
     44e:	90 93 45 01 	sts	0x0145, r25
     452:	80 93 44 01 	sts	0x0144, r24
     456:	8f ef       	ldi	r24, 0xFF	; 255
     458:	9f ef       	ldi	r25, 0xFF	; 255
     45a:	90 93 51 01 	sts	0x0151, r25
     45e:	80 93 50 01 	sts	0x0150, r24
     462:	08 95       	ret

00000464 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     464:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     466:	81 8d       	ldd	r24, Z+25	; 0x19
     468:	22 8d       	ldd	r18, Z+26	; 0x1a
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	80 5c       	subi	r24, 0xC0	; 192
     46e:	9f 4f       	sbci	r25, 0xFF	; 255
     470:	82 1b       	sub	r24, r18
     472:	91 09       	sbc	r25, r1
}
     474:	8f 73       	andi	r24, 0x3F	; 63
     476:	99 27       	eor	r25, r25
     478:	08 95       	ret

0000047a <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     47a:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     47c:	91 8d       	ldd	r25, Z+25	; 0x19
     47e:	82 8d       	ldd	r24, Z+26	; 0x1a
     480:	98 17       	cp	r25, r24
     482:	31 f0       	breq	.+12     	; 0x490 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     484:	82 8d       	ldd	r24, Z+26	; 0x1a
     486:	e8 0f       	add	r30, r24
     488:	f1 1d       	adc	r31, r1
     48a:	85 8d       	ldd	r24, Z+29	; 0x1d
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     490:	8f ef       	ldi	r24, 0xFF	; 255
     492:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     494:	08 95       	ret

00000496 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     496:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     498:	91 8d       	ldd	r25, Z+25	; 0x19
     49a:	82 8d       	ldd	r24, Z+26	; 0x1a
     49c:	98 17       	cp	r25, r24
     49e:	61 f0       	breq	.+24     	; 0x4b8 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     4a0:	82 8d       	ldd	r24, Z+26	; 0x1a
     4a2:	df 01       	movw	r26, r30
     4a4:	a8 0f       	add	r26, r24
     4a6:	b1 1d       	adc	r27, r1
     4a8:	5d 96       	adiw	r26, 0x1d	; 29
     4aa:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     4ac:	92 8d       	ldd	r25, Z+26	; 0x1a
     4ae:	9f 5f       	subi	r25, 0xFF	; 255
     4b0:	9f 73       	andi	r25, 0x3F	; 63
     4b2:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     4b8:	8f ef       	ldi	r24, 0xFF	; 255
     4ba:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     4bc:	08 95       	ret

000004be <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     4be:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     4c0:	84 8d       	ldd	r24, Z+28	; 0x1c
     4c2:	df 01       	movw	r26, r30
     4c4:	a8 0f       	add	r26, r24
     4c6:	b1 1d       	adc	r27, r1
     4c8:	a3 5a       	subi	r26, 0xA3	; 163
     4ca:	bf 4f       	sbci	r27, 0xFF	; 255
     4cc:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     4ce:	84 8d       	ldd	r24, Z+28	; 0x1c
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	01 96       	adiw	r24, 0x01	; 1
     4d4:	8f 73       	andi	r24, 0x3F	; 63
     4d6:	90 78       	andi	r25, 0x80	; 128
     4d8:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     4da:	a6 89       	ldd	r26, Z+22	; 0x16
     4dc:	b7 89       	ldd	r27, Z+23	; 0x17
     4de:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
     4e0:	a0 89       	ldd	r26, Z+16	; 0x10
     4e2:	b1 89       	ldd	r27, Z+17	; 0x11
     4e4:	8c 91       	ld	r24, X
     4e6:	80 64       	ori	r24, 0x40	; 64
     4e8:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
     4ea:	93 8d       	ldd	r25, Z+27	; 0x1b
     4ec:	84 8d       	ldd	r24, Z+28	; 0x1c
     4ee:	98 13       	cpse	r25, r24
     4f0:	06 c0       	rjmp	.+12     	; 0x4fe <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     4f2:	02 88       	ldd	r0, Z+18	; 0x12
     4f4:	f3 89       	ldd	r31, Z+19	; 0x13
     4f6:	e0 2d       	mov	r30, r0
     4f8:	80 81       	ld	r24, Z
     4fa:	8f 7d       	andi	r24, 0xDF	; 223
     4fc:	80 83       	st	Z, r24
     4fe:	08 95       	ret

00000500 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     500:	cf 93       	push	r28
     502:	df 93       	push	r29
     504:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     506:	88 8d       	ldd	r24, Y+24	; 0x18
     508:	81 11       	cpse	r24, r1
     50a:	0b c0       	rjmp	.+22     	; 0x522 <_ZN14HardwareSerial5flushEv+0x22>
     50c:	1b c0       	rjmp	.+54     	; 0x544 <_ZN14HardwareSerial5flushEv+0x44>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	07 fc       	sbrc	r0, 7
     512:	09 c0       	rjmp	.+18     	; 0x526 <_ZN14HardwareSerial5flushEv+0x26>
     514:	80 81       	ld	r24, Z
     516:	85 ff       	sbrs	r24, 5
     518:	06 c0       	rjmp	.+12     	; 0x526 <_ZN14HardwareSerial5flushEv+0x26>
     51a:	0e c0       	rjmp	.+28     	; 0x538 <_ZN14HardwareSerial5flushEv+0x38>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
     51c:	ce 01       	movw	r24, r28
     51e:	0e 94 5f 02 	call	0x4be	; 0x4be <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     522:	ea 89       	ldd	r30, Y+18	; 0x12
     524:	fb 89       	ldd	r31, Y+19	; 0x13
     526:	80 81       	ld	r24, Z
     528:	85 fd       	sbrc	r24, 5
     52a:	f1 cf       	rjmp	.-30     	; 0x50e <_ZN14HardwareSerial5flushEv+0xe>
     52c:	a8 89       	ldd	r26, Y+16	; 0x10
     52e:	b9 89       	ldd	r27, Y+17	; 0x11
     530:	8c 91       	ld	r24, X
     532:	86 ff       	sbrs	r24, 6
     534:	ec cf       	rjmp	.-40     	; 0x50e <_ZN14HardwareSerial5flushEv+0xe>
     536:	06 c0       	rjmp	.+12     	; 0x544 <_ZN14HardwareSerial5flushEv+0x44>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     538:	a8 89       	ldd	r26, Y+16	; 0x10
     53a:	b9 89       	ldd	r27, Y+17	; 0x11
     53c:	8c 91       	ld	r24, X
     53e:	85 ff       	sbrs	r24, 5
     540:	f2 cf       	rjmp	.-28     	; 0x526 <_ZN14HardwareSerial5flushEv+0x26>
     542:	ec cf       	rjmp	.-40     	; 0x51c <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     544:	df 91       	pop	r29
     546:	cf 91       	pop	r28
     548:	08 95       	ret

0000054a <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	ec 01       	movw	r28, r24
     554:	16 2f       	mov	r17, r22
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     556:	9b 8d       	ldd	r25, Y+27	; 0x1b
     558:	8c 8d       	ldd	r24, Y+28	; 0x1c
     55a:	98 13       	cpse	r25, r24
     55c:	24 c0       	rjmp	.+72     	; 0x5a6 <_ZN14HardwareSerial5writeEh+0x5c>
     55e:	e8 89       	ldd	r30, Y+16	; 0x10
     560:	f9 89       	ldd	r31, Y+17	; 0x11
     562:	80 81       	ld	r24, Z
     564:	85 fd       	sbrc	r24, 5
     566:	26 c0       	rjmp	.+76     	; 0x5b4 <_ZN14HardwareSerial5writeEh+0x6a>
     568:	1e c0       	rjmp	.+60     	; 0x5a6 <_ZN14HardwareSerial5writeEh+0x5c>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
     56a:	0f b6       	in	r0, 0x3f	; 63
     56c:	07 fc       	sbrc	r0, 7
     56e:	08 c0       	rjmp	.+16     	; 0x580 <_ZN14HardwareSerial5writeEh+0x36>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     570:	e8 89       	ldd	r30, Y+16	; 0x10
     572:	f9 89       	ldd	r31, Y+17	; 0x11
     574:	80 81       	ld	r24, Z
     576:	85 ff       	sbrs	r24, 5
     578:	03 c0       	rjmp	.+6      	; 0x580 <_ZN14HardwareSerial5writeEh+0x36>
	_tx_udr_empty_irq();
     57a:	ce 01       	movw	r24, r28
     57c:	0e 94 5f 02 	call	0x4be	; 0x4be <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     580:	9c 8d       	ldd	r25, Y+28	; 0x1c
     582:	09 17       	cp	r16, r25
     584:	91 f3       	breq	.-28     	; 0x56a <_ZN14HardwareSerial5writeEh+0x20>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     586:	8b 8d       	ldd	r24, Y+27	; 0x1b
     588:	fe 01       	movw	r30, r28
     58a:	e8 0f       	add	r30, r24
     58c:	f1 1d       	adc	r31, r1
     58e:	e3 5a       	subi	r30, 0xA3	; 163
     590:	ff 4f       	sbci	r31, 0xFF	; 255
     592:	10 83       	st	Z, r17
  _tx_buffer_head = i;
     594:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
     596:	ea 89       	ldd	r30, Y+18	; 0x12
     598:	fb 89       	ldd	r31, Y+19	; 0x13
     59a:	80 81       	ld	r24, Z
     59c:	80 62       	ori	r24, 0x20	; 32
     59e:	80 83       	st	Z, r24
  _written = true;
     5a0:	81 e0       	ldi	r24, 0x01	; 1
     5a2:	88 8f       	std	Y+24, r24	; 0x18
  
  return 1;
     5a4:	0f c0       	rjmp	.+30     	; 0x5c4 <_ZN14HardwareSerial5writeEh+0x7a>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     5a6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	01 96       	adiw	r24, 0x01	; 1
     5ac:	8f 73       	andi	r24, 0x3F	; 63
     5ae:	90 78       	andi	r25, 0x80	; 128
     5b0:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     5b2:	e6 cf       	rjmp	.-52     	; 0x580 <_ZN14HardwareSerial5writeEh+0x36>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
     5b4:	ee 89       	ldd	r30, Y+22	; 0x16
     5b6:	ff 89       	ldd	r31, Y+23	; 0x17
     5b8:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
     5ba:	e8 89       	ldd	r30, Y+16	; 0x10
     5bc:	f9 89       	ldd	r31, Y+17	; 0x11
     5be:	80 81       	ld	r24, Z
     5c0:	80 64       	ori	r24, 0x40	; 64
     5c2:	80 83       	st	Z, r24
	
  sbi(*_ucsrb, UDRIE0);
  _written = true;
  
  return 1;
}
     5c4:	81 e0       	ldi	r24, 0x01	; 1
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	df 91       	pop	r29
     5ca:	cf 91       	pop	r28
     5cc:	1f 91       	pop	r17
     5ce:	0f 91       	pop	r16
     5d0:	08 95       	ret

000005d2 <_ZN14HardwareSerial5beginEmh>:

// Public Methods //////////////////////////////////////////////////////////////


void HardwareSerial::begin(unsigned long baud, byte config)
{
     5d2:	cf 92       	push	r12
     5d4:	df 92       	push	r13
     5d6:	ef 92       	push	r14
     5d8:	ff 92       	push	r15
     5da:	1f 93       	push	r17
     5dc:	cf 93       	push	r28
     5de:	df 93       	push	r29
     5e0:	ec 01       	movw	r28, r24
     5e2:	6a 01       	movw	r12, r20
     5e4:	7b 01       	movw	r14, r22
     5e6:	12 2f       	mov	r17, r18
	
	// Try u2x mode first
	uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     5e8:	62 e1       	ldi	r22, 0x12	; 18
     5ea:	7a e7       	ldi	r23, 0x7A	; 122
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	a7 01       	movw	r20, r14
     5f2:	96 01       	movw	r18, r12
     5f4:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
     5f8:	ba 01       	movw	r22, r20
     5fa:	a9 01       	movw	r20, r18
     5fc:	41 50       	subi	r20, 0x01	; 1
     5fe:	51 09       	sbc	r21, r1
     600:	61 09       	sbc	r22, r1
     602:	71 09       	sbc	r23, r1
     604:	76 95       	lsr	r23
     606:	67 95       	ror	r22
     608:	57 95       	ror	r21
     60a:	47 95       	ror	r20
	*_ucsra = 1 << U2X0;
     60c:	e8 89       	ldd	r30, Y+16	; 0x10
     60e:	f9 89       	ldd	r31, Y+17	; 0x11
     610:	82 e0       	ldi	r24, 0x02	; 2
     612:	80 83       	st	Z, r24
	// hardcoded exception for 57600 for compatibility with the bootloader
	// shipped with the Duemilanove and previous boards and the firmware
	// on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
	// be > 4095, so switch back to non-u2x mode if the baud rate is too
	// low.
	if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     614:	41 15       	cp	r20, r1
     616:	80 e1       	ldi	r24, 0x10	; 16
     618:	58 07       	cpc	r21, r24
     61a:	a8 f0       	brcs	.+42     	; 0x646 <__stack+0x47>
	{
		*_ucsra = 0;
     61c:	e8 89       	ldd	r30, Y+16	; 0x10
     61e:	f9 89       	ldd	r31, Y+17	; 0x11
     620:	10 82       	st	Z, r1
		baud_setting = (F_CPU/ 8 / baud - 1) / 2;
     622:	69 e0       	ldi	r22, 0x09	; 9
     624:	7d e3       	ldi	r23, 0x3D	; 61
     626:	80 e0       	ldi	r24, 0x00	; 0
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	a7 01       	movw	r20, r14
     62c:	96 01       	movw	r18, r12
     62e:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
     632:	da 01       	movw	r26, r20
     634:	c9 01       	movw	r24, r18
     636:	01 97       	sbiw	r24, 0x01	; 1
     638:	a1 09       	sbc	r26, r1
     63a:	b1 09       	sbc	r27, r1
     63c:	b6 95       	lsr	r27
     63e:	a7 95       	ror	r26
     640:	97 95       	ror	r25
     642:	87 95       	ror	r24
     644:	ac 01       	movw	r20, r24
	}

	// assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
	*_ubrrh = baud_setting >> 8;
     646:	ec 85       	ldd	r30, Y+12	; 0x0c
     648:	fd 85       	ldd	r31, Y+13	; 0x0d
     64a:	50 83       	st	Z, r21
	*_ubrrl = baud_setting;
     64c:	ee 85       	ldd	r30, Y+14	; 0x0e
     64e:	ff 85       	ldd	r31, Y+15	; 0x0f
     650:	40 83       	st	Z, r20

	_written = false;
     652:	18 8e       	std	Y+24, r1	; 0x18

	//set the data bits, parity, and stop bits
	#if defined(__AVR_ATmega8__)
	config |= 0x80; // select UCSRC register (shared with UBRRH)
	#endif
	*_ucsrc = config;
     654:	ec 89       	ldd	r30, Y+20	; 0x14
     656:	fd 89       	ldd	r31, Y+21	; 0x15
     658:	10 83       	st	Z, r17
	
	sbi(*_ucsrb, RXEN0);
     65a:	ea 89       	ldd	r30, Y+18	; 0x12
     65c:	fb 89       	ldd	r31, Y+19	; 0x13
     65e:	80 81       	ld	r24, Z
     660:	80 61       	ori	r24, 0x10	; 16
     662:	80 83       	st	Z, r24
	sbi(*_ucsrb, TXEN0);
     664:	ea 89       	ldd	r30, Y+18	; 0x12
     666:	fb 89       	ldd	r31, Y+19	; 0x13
     668:	80 81       	ld	r24, Z
     66a:	88 60       	ori	r24, 0x08	; 8
     66c:	80 83       	st	Z, r24
	sbi(*_ucsrb, RXCIE0);
     66e:	ea 89       	ldd	r30, Y+18	; 0x12
     670:	fb 89       	ldd	r31, Y+19	; 0x13
     672:	80 81       	ld	r24, Z
     674:	80 68       	ori	r24, 0x80	; 128
     676:	80 83       	st	Z, r24
	cbi(*_ucsrb, UDRIE0);
     678:	ea 89       	ldd	r30, Y+18	; 0x12
     67a:	fb 89       	ldd	r31, Y+19	; 0x13
     67c:	80 81       	ld	r24, Z
     67e:	8f 7d       	andi	r24, 0xDF	; 223
     680:	80 83       	st	Z, r24
}
     682:	df 91       	pop	r29
     684:	cf 91       	pop	r28
     686:	1f 91       	pop	r17
     688:	ff 90       	pop	r15
     68a:	ef 90       	pop	r14
     68c:	df 90       	pop	r13
     68e:	cf 90       	pop	r12
     690:	08 95       	ret

00000692 <__vector_25>:
#elif defined(USART1_RX_vect)
ISR(USART1_RX_vect)
#else
#error "Don't know what the Data Register Empty vector is called for Serial1"
#endif
{
     692:	1f 92       	push	r1
     694:	0f 92       	push	r0
     696:	0f b6       	in	r0, 0x3f	; 63
     698:	0f 92       	push	r0
     69a:	11 24       	eor	r1, r1
     69c:	2f 93       	push	r18
     69e:	8f 93       	push	r24
     6a0:	9f 93       	push	r25
     6a2:	af 93       	push	r26
     6a4:	bf 93       	push	r27
     6a6:	ef 93       	push	r30
     6a8:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     6aa:	e0 91 a4 01 	lds	r30, 0x01A4
     6ae:	f0 91 a5 01 	lds	r31, 0x01A5
     6b2:	80 81       	ld	r24, Z
     6b4:	82 fd       	sbrc	r24, 2
     6b6:	17 c0       	rjmp	.+46     	; 0x6e6 <__vector_25+0x54>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     6b8:	e0 91 aa 01 	lds	r30, 0x01AA
     6bc:	f0 91 ab 01 	lds	r31, 0x01AB
     6c0:	20 81       	ld	r18, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     6c2:	80 91 ad 01 	lds	r24, 0x01AD
     6c6:	8f 5f       	subi	r24, 0xFF	; 255
     6c8:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     6ca:	90 91 ae 01 	lds	r25, 0x01AE
     6ce:	89 17       	cp	r24, r25
     6d0:	79 f0       	breq	.+30     	; 0x6f0 <__vector_25+0x5e>
      _rx_buffer[_rx_buffer_head] = c;
     6d2:	ed ea       	ldi	r30, 0xAD	; 173
     6d4:	f1 e0       	ldi	r31, 0x01	; 1
     6d6:	a0 81       	ld	r26, Z
     6d8:	b0 e0       	ldi	r27, 0x00	; 0
     6da:	ac 56       	subi	r26, 0x6C	; 108
     6dc:	be 4f       	sbci	r27, 0xFE	; 254
     6de:	5d 96       	adiw	r26, 0x1d	; 29
     6e0:	2c 93       	st	X, r18
      _rx_buffer_head = i;
     6e2:	80 83       	st	Z, r24
     6e4:	05 c0       	rjmp	.+10     	; 0x6f0 <__vector_25+0x5e>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     6e6:	e0 91 aa 01 	lds	r30, 0x01AA
     6ea:	f0 91 ab 01 	lds	r31, 0x01AB
     6ee:	80 81       	ld	r24, Z
  Serial1._rx_complete_irq();
}
     6f0:	ff 91       	pop	r31
     6f2:	ef 91       	pop	r30
     6f4:	bf 91       	pop	r27
     6f6:	af 91       	pop	r26
     6f8:	9f 91       	pop	r25
     6fa:	8f 91       	pop	r24
     6fc:	2f 91       	pop	r18
     6fe:	0f 90       	pop	r0
     700:	0f be       	out	0x3f, r0	; 63
     702:	0f 90       	pop	r0
     704:	1f 90       	pop	r1
     706:	18 95       	reti

00000708 <__vector_26>:
#elif defined(USART1_UDRE_vect)
ISR(USART1_UDRE_vect)
#else
#error "Don't know what the Data Register Empty vector is called for Serial1"
#endif
{
     708:	1f 92       	push	r1
     70a:	0f 92       	push	r0
     70c:	0f b6       	in	r0, 0x3f	; 63
     70e:	0f 92       	push	r0
     710:	11 24       	eor	r1, r1
     712:	2f 93       	push	r18
     714:	3f 93       	push	r19
     716:	4f 93       	push	r20
     718:	5f 93       	push	r21
     71a:	6f 93       	push	r22
     71c:	7f 93       	push	r23
     71e:	8f 93       	push	r24
     720:	9f 93       	push	r25
     722:	af 93       	push	r26
     724:	bf 93       	push	r27
     726:	ef 93       	push	r30
     728:	ff 93       	push	r31
  Serial1._tx_udr_empty_irq();
     72a:	84 e9       	ldi	r24, 0x94	; 148
     72c:	91 e0       	ldi	r25, 0x01	; 1
     72e:	0e 94 5f 02 	call	0x4be	; 0x4be <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
     732:	ff 91       	pop	r31
     734:	ef 91       	pop	r30
     736:	bf 91       	pop	r27
     738:	af 91       	pop	r26
     73a:	9f 91       	pop	r25
     73c:	8f 91       	pop	r24
     73e:	7f 91       	pop	r23
     740:	6f 91       	pop	r22
     742:	5f 91       	pop	r21
     744:	4f 91       	pop	r20
     746:	3f 91       	pop	r19
     748:	2f 91       	pop	r18
     74a:	0f 90       	pop	r0
     74c:	0f be       	out	0x3f, r0	; 63
     74e:	0f 90       	pop	r0
     750:	1f 90       	pop	r1
     752:	18 95       	reti

00000754 <_GLOBAL__sub_I___vector_25>:
     754:	10 92 97 01 	sts	0x0197, r1
     758:	10 92 96 01 	sts	0x0196, r1
     75c:	88 ee       	ldi	r24, 0xE8	; 232
     75e:	93 e0       	ldi	r25, 0x03	; 3
     760:	a0 e0       	ldi	r26, 0x00	; 0
     762:	b0 e0       	ldi	r27, 0x00	; 0
     764:	80 93 98 01 	sts	0x0198, r24
     768:	90 93 99 01 	sts	0x0199, r25
     76c:	a0 93 9a 01 	sts	0x019A, r26
     770:	b0 93 9b 01 	sts	0x019B, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     774:	8e e1       	ldi	r24, 0x1E	; 30
     776:	91 e0       	ldi	r25, 0x01	; 1
     778:	90 93 95 01 	sts	0x0195, r25
     77c:	80 93 94 01 	sts	0x0194, r24
     780:	8d ec       	ldi	r24, 0xCD	; 205
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	90 93 a1 01 	sts	0x01A1, r25
     788:	80 93 a0 01 	sts	0x01A0, r24
     78c:	8c ec       	ldi	r24, 0xCC	; 204
     78e:	90 e0       	ldi	r25, 0x00	; 0
     790:	90 93 a3 01 	sts	0x01A3, r25
     794:	80 93 a2 01 	sts	0x01A2, r24
     798:	88 ec       	ldi	r24, 0xC8	; 200
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	90 93 a5 01 	sts	0x01A5, r25
     7a0:	80 93 a4 01 	sts	0x01A4, r24
     7a4:	89 ec       	ldi	r24, 0xC9	; 201
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	90 93 a7 01 	sts	0x01A7, r25
     7ac:	80 93 a6 01 	sts	0x01A6, r24
     7b0:	8a ec       	ldi	r24, 0xCA	; 202
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	90 93 a9 01 	sts	0x01A9, r25
     7b8:	80 93 a8 01 	sts	0x01A8, r24
     7bc:	8e ec       	ldi	r24, 0xCE	; 206
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	90 93 ab 01 	sts	0x01AB, r25
     7c4:	80 93 aa 01 	sts	0x01AA, r24
     7c8:	10 92 ad 01 	sts	0x01AD, r1
     7cc:	10 92 ae 01 	sts	0x01AE, r1
     7d0:	10 92 af 01 	sts	0x01AF, r1
     7d4:	10 92 b0 01 	sts	0x01B0, r1
     7d8:	08 95       	ret

000007da <_ZN9Keyboard_5writeEh>:
	_keyReport.modifiers = 0;
	sendReport(&_keyReport);
}

size_t Keyboard_::write(uint8_t c)
{	
     7da:	ff 92       	push	r15
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ec 01       	movw	r28, r24
     7e6:	f6 2e       	mov	r15, r22
	uint8_t p = press(c);  // Keydown
     7e8:	e8 81       	ld	r30, Y
     7ea:	f9 81       	ldd	r31, Y+1	; 0x01
     7ec:	04 80       	ldd	r0, Z+4	; 0x04
     7ee:	f5 81       	ldd	r31, Z+5	; 0x05
     7f0:	e0 2d       	mov	r30, r0
     7f2:	09 95       	icall
     7f4:	8c 01       	movw	r16, r24
	release(c);            // Keyup
     7f6:	e8 81       	ld	r30, Y
     7f8:	f9 81       	ldd	r31, Y+1	; 0x01
     7fa:	06 80       	ldd	r0, Z+6	; 0x06
     7fc:	f7 81       	ldd	r31, Z+7	; 0x07
     7fe:	e0 2d       	mov	r30, r0
     800:	6f 2d       	mov	r22, r15
     802:	ce 01       	movw	r24, r28
     804:	09 95       	icall
	return p;              // just return the result of press() since release() almost always returns 1
}
     806:	c8 01       	movw	r24, r16
     808:	99 27       	eor	r25, r25
     80a:	df 91       	pop	r29
     80c:	cf 91       	pop	r28
     80e:	1f 91       	pop	r17
     810:	0f 91       	pop	r16
     812:	ff 90       	pop	r15
     814:	08 95       	ret

00000816 <_Z16HID_GetInterfacePh>:

#define WEAK __attribute__ ((weak))

int WEAK HID_GetInterface(u8* interfaceNum)
{
	interfaceNum[0] += 1;	// uses 1
     816:	fc 01       	movw	r30, r24
     818:	20 81       	ld	r18, Z
     81a:	2f 5f       	subi	r18, 0xFF	; 255
     81c:	20 83       	st	Z, r18
	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
     81e:	49 e1       	ldi	r20, 0x19	; 25
     820:	50 e0       	ldi	r21, 0x00	; 0
     822:	6e e6       	ldi	r22, 0x6E	; 110
     824:	71 e0       	ldi	r23, 0x01	; 1
     826:	80 e8       	ldi	r24, 0x80	; 128
     828:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z15USB_SendControlhPKvi>
}
     82c:	08 95       	ret

0000082e <_Z17HID_GetDescriptori>:

int WEAK HID_GetDescriptor(int /* i */)
{
	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
     82e:	45 e6       	ldi	r20, 0x65	; 101
     830:	50 e0       	ldi	r21, 0x00	; 0
     832:	67 e8       	ldi	r22, 0x87	; 135
     834:	71 e0       	ldi	r23, 0x01	; 1
     836:	80 e8       	ldi	r24, 0x80	; 128
     838:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z15USB_SendControlhPKvi>
}
     83c:	08 95       	ret

0000083e <_Z14HID_SendReporthPKvi>:

void WEAK HID_SendReport(u8 id, const void* data, int len)
{
     83e:	ef 92       	push	r14
     840:	ff 92       	push	r15
     842:	0f 93       	push	r16
     844:	1f 93       	push	r17
     846:	cf 93       	push	r28
     848:	df 93       	push	r29
     84a:	1f 92       	push	r1
     84c:	cd b7       	in	r28, 0x3d	; 61
     84e:	de b7       	in	r29, 0x3e	; 62
     850:	89 83       	std	Y+1, r24	; 0x01
     852:	8b 01       	movw	r16, r22
     854:	7a 01       	movw	r14, r20
	USB_Send(HID_TX, &id, 1);
     856:	41 e0       	ldi	r20, 0x01	; 1
     858:	50 e0       	ldi	r21, 0x00	; 0
     85a:	be 01       	movw	r22, r28
     85c:	6f 5f       	subi	r22, 0xFF	; 255
     85e:	7f 4f       	sbci	r23, 0xFF	; 255
     860:	84 e0       	ldi	r24, 0x04	; 4
     862:	0e 94 75 07 	call	0xeea	; 0xeea <_Z8USB_SendhPKvi>
	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
     866:	a7 01       	movw	r20, r14
     868:	b8 01       	movw	r22, r16
     86a:	84 e4       	ldi	r24, 0x44	; 68
     86c:	0e 94 75 07 	call	0xeea	; 0xeea <_Z8USB_SendhPKvi>
}
     870:	0f 90       	pop	r0
     872:	df 91       	pop	r29
     874:	cf 91       	pop	r28
     876:	1f 91       	pop	r17
     878:	0f 91       	pop	r16
     87a:	ff 90       	pop	r15
     87c:	ef 90       	pop	r14
     87e:	08 95       	ret

00000880 <_Z9HID_SetupR5Setup>:

bool WEAK HID_Setup(Setup& setup)
{
     880:	fc 01       	movw	r30, r24
	u8 r = setup.bRequest;
     882:	91 81       	ldd	r25, Z+1	; 0x01
	u8 requestType = setup.bmRequestType;
     884:	80 81       	ld	r24, Z
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
     886:	81 3a       	cpi	r24, 0xA1	; 161
     888:	31 f4       	brne	.+12     	; 0x896 <_Z9HID_SetupR5Setup+0x16>
	{
		if (HID_GET_REPORT == r)
     88a:	9d 7f       	andi	r25, 0xFD	; 253
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	91 30       	cpi	r25, 0x01	; 1
     890:	a9 f0       	breq	.+42     	; 0x8bc <_Z9HID_SetupR5Setup+0x3c>
     892:	80 e0       	ldi	r24, 0x00	; 0
     894:	08 95       	ret
			//Send8(_hid_protocol);	// TODO
			return true;
		}
	}
	
	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
     896:	81 32       	cpi	r24, 0x21	; 33
     898:	71 f4       	brne	.+28     	; 0x8b6 <_Z9HID_SetupR5Setup+0x36>
	{
		if (HID_SET_PROTOCOL == r)
     89a:	9b 30       	cpi	r25, 0x0B	; 11
     89c:	29 f4       	brne	.+10     	; 0x8a8 <_Z9HID_SetupR5Setup+0x28>
		{
			_hid_protocol = setup.wValueL;
     89e:	82 81       	ldd	r24, Z+2	; 0x02
     8a0:	80 93 09 01 	sts	0x0109, r24
			return true;
     8a4:	81 e0       	ldi	r24, 0x01	; 1
     8a6:	08 95       	ret
		}

		if (HID_SET_IDLE == r)
     8a8:	9a 30       	cpi	r25, 0x0A	; 10
     8aa:	39 f4       	brne	.+14     	; 0x8ba <_Z9HID_SetupR5Setup+0x3a>
		{
			_hid_idle = setup.wValueL;
     8ac:	82 81       	ldd	r24, Z+2	; 0x02
     8ae:	80 93 08 01 	sts	0x0108, r24
			return true;
     8b2:	81 e0       	ldi	r24, 0x01	; 1
     8b4:	08 95       	ret
		}
	}
	return false;
     8b6:	80 e0       	ldi	r24, 0x00	; 0
     8b8:	08 95       	ret
     8ba:	80 e0       	ldi	r24, 0x00	; 0
}
     8bc:	08 95       	ret

000008be <_ZN6Mouse_C1Ev>:

//================================================================================
//================================================================================
//	Mouse

Mouse_::Mouse_(void) : _buttons(0)
     8be:	fc 01       	movw	r30, r24
     8c0:	10 82       	st	Z, r1
     8c2:	08 95       	ret

000008c4 <_ZN9Keyboard_C1Ev>:
     8c4:	fc 01       	movw	r30, r24
     8c6:	13 82       	std	Z+3, r1	; 0x03
     8c8:	12 82       	std	Z+2, r1	; 0x02

//================================================================================
//================================================================================
//	Keyboard

Keyboard_::Keyboard_(void) 
     8ca:	2e e2       	ldi	r18, 0x2E	; 46
     8cc:	31 e0       	ldi	r19, 0x01	; 1
     8ce:	31 83       	std	Z+1, r19	; 0x01
     8d0:	20 83       	st	Z, r18
     8d2:	08 95       	ret

000008d4 <_ZN9Keyboard_10sendReportEP9KeyReport>:
{
}

void Keyboard_::sendReport(KeyReport* keys)
{
	HID_SendReport(2,keys,sizeof(KeyReport));
     8d4:	48 e0       	ldi	r20, 0x08	; 8
     8d6:	50 e0       	ldi	r21, 0x00	; 0
     8d8:	82 e0       	ldi	r24, 0x02	; 2
     8da:	0e 94 1f 04 	call	0x83e	; 0x83e <_Z14HID_SendReporthPKvi>
     8de:	08 95       	ret

000008e0 <_ZN9Keyboard_5pressEh>:
// USB HID works, the host acts like the key remains pressed until we 
// call release(), releaseAll(), or otherwise clear the report and resend.
size_t Keyboard_::press(uint8_t k) 
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
     8e0:	68 38       	cpi	r22, 0x88	; 136
     8e2:	18 f0       	brcs	.+6      	; 0x8ea <_ZN9Keyboard_5pressEh+0xa>
		k = k - 136;
     8e4:	e8 e7       	ldi	r30, 0x78	; 120
     8e6:	e6 0f       	add	r30, r22
     8e8:	2e c0       	rjmp	.+92     	; 0x946 <_ZN9Keyboard_5pressEh+0x66>
	} else if (k >= 128) {	// it's a modifier key
     8ea:	66 23       	and	r22, r22
     8ec:	9c f4       	brge	.+38     	; 0x914 <_ZN9Keyboard_5pressEh+0x34>
		_keyReport.modifiers |= (1<<(k-128));
     8ee:	60 58       	subi	r22, 0x80	; 128
     8f0:	21 e0       	ldi	r18, 0x01	; 1
     8f2:	30 e0       	ldi	r19, 0x00	; 0
     8f4:	a9 01       	movw	r20, r18
     8f6:	02 c0       	rjmp	.+4      	; 0x8fc <_ZN9Keyboard_5pressEh+0x1c>
     8f8:	44 0f       	add	r20, r20
     8fa:	55 1f       	adc	r21, r21
     8fc:	6a 95       	dec	r22
     8fe:	e2 f7       	brpl	.-8      	; 0x8f8 <_ZN9Keyboard_5pressEh+0x18>
     900:	ba 01       	movw	r22, r20
     902:	dc 01       	movw	r26, r24
     904:	14 96       	adiw	r26, 0x04	; 4
     906:	ec 91       	ld	r30, X
     908:	14 97       	sbiw	r26, 0x04	; 4
     90a:	6e 2b       	or	r22, r30
     90c:	14 96       	adiw	r26, 0x04	; 4
     90e:	6c 93       	st	X, r22
		k = 0;
     910:	e0 e0       	ldi	r30, 0x00	; 0
     912:	19 c0       	rjmp	.+50     	; 0x946 <_ZN9Keyboard_5pressEh+0x66>
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
     914:	e6 2f       	mov	r30, r22
     916:	f0 e0       	ldi	r31, 0x00	; 0
     918:	e2 51       	subi	r30, 0x12	; 18
     91a:	ff 4f       	sbci	r31, 0xFF	; 255
     91c:	e4 91       	lpm	r30, Z
		if (!k) {
     91e:	e1 11       	cpse	r30, r1
     920:	08 c0       	rjmp	.+16     	; 0x932 <_ZN9Keyboard_5pressEh+0x52>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     922:	21 e0       	ldi	r18, 0x01	; 1
     924:	30 e0       	ldi	r19, 0x00	; 0
     926:	fc 01       	movw	r30, r24
     928:	33 83       	std	Z+3, r19	; 0x03
     92a:	22 83       	std	Z+2, r18	; 0x02
			setWriteError();
			return 0;
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	08 95       	ret
		}
		if (k & 0x80) {						// it's a capital letter or other character reached with shift
     932:	ee 23       	and	r30, r30
     934:	44 f4       	brge	.+16     	; 0x946 <_ZN9Keyboard_5pressEh+0x66>
			_keyReport.modifiers |= 0x02;	// the left shift modifier
     936:	dc 01       	movw	r26, r24
     938:	14 96       	adiw	r26, 0x04	; 4
     93a:	2c 91       	ld	r18, X
     93c:	14 97       	sbiw	r26, 0x04	; 4
     93e:	22 60       	ori	r18, 0x02	; 2
     940:	14 96       	adiw	r26, 0x04	; 4
     942:	2c 93       	st	X, r18
			k &= 0x7F;
     944:	ef 77       	andi	r30, 0x7F	; 127
		}
	}
	
	// Add k to the key report only if it's not already present
	// and if there is an empty slot.
	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
     946:	dc 01       	movw	r26, r24
     948:	16 96       	adiw	r26, 0x06	; 6
     94a:	2c 91       	ld	r18, X
     94c:	16 97       	sbiw	r26, 0x06	; 6
     94e:	2e 17       	cp	r18, r30
     950:	09 f4       	brne	.+2      	; 0x954 <_ZN9Keyboard_5pressEh+0x74>
     952:	40 c0       	rjmp	.+128    	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
     954:	17 96       	adiw	r26, 0x07	; 7
     956:	3c 91       	ld	r19, X
     958:	17 97       	sbiw	r26, 0x07	; 7
     95a:	3e 17       	cp	r19, r30
     95c:	d9 f1       	breq	.+118    	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
     95e:	18 96       	adiw	r26, 0x08	; 8
     960:	3c 91       	ld	r19, X
     962:	18 97       	sbiw	r26, 0x08	; 8
     964:	3e 17       	cp	r19, r30
     966:	b1 f1       	breq	.+108    	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
     968:	19 96       	adiw	r26, 0x09	; 9
     96a:	3c 91       	ld	r19, X
     96c:	19 97       	sbiw	r26, 0x09	; 9
     96e:	3e 17       	cp	r19, r30
     970:	89 f1       	breq	.+98     	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
     972:	1a 96       	adiw	r26, 0x0a	; 10
     974:	3c 91       	ld	r19, X
     976:	1a 97       	sbiw	r26, 0x0a	; 10
     978:	3e 17       	cp	r19, r30
     97a:	61 f1       	breq	.+88     	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
     97c:	1b 96       	adiw	r26, 0x0b	; 11
     97e:	3c 91       	ld	r19, X
     980:	3e 17       	cp	r19, r30
     982:	41 f1       	breq	.+80     	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
		
		for (i=0; i<6; i++) {
			if (_keyReport.keys[i] == 0x00) {
     984:	22 23       	and	r18, r18
     986:	61 f0       	breq	.+24     	; 0x9a0 <_ZN9Keyboard_5pressEh+0xc0>
     988:	21 e0       	ldi	r18, 0x01	; 1
     98a:	30 e0       	ldi	r19, 0x00	; 0
     98c:	62 2f       	mov	r22, r18
     98e:	a9 01       	movw	r20, r18
     990:	dc 01       	movw	r26, r24
     992:	a2 0f       	add	r26, r18
     994:	b3 1f       	adc	r27, r19
     996:	16 96       	adiw	r26, 0x06	; 6
     998:	7c 91       	ld	r23, X
     99a:	71 11       	cpse	r23, r1
     99c:	0a c0       	rjmp	.+20     	; 0x9b2 <_ZN9Keyboard_5pressEh+0xd2>
     99e:	03 c0       	rjmp	.+6      	; 0x9a6 <_ZN9Keyboard_5pressEh+0xc6>
     9a0:	40 e0       	ldi	r20, 0x00	; 0
     9a2:	50 e0       	ldi	r21, 0x00	; 0
     9a4:	60 e0       	ldi	r22, 0x00	; 0
				_keyReport.keys[i] = k;
     9a6:	dc 01       	movw	r26, r24
     9a8:	a4 0f       	add	r26, r20
     9aa:	b5 1f       	adc	r27, r21
     9ac:	16 96       	adiw	r26, 0x06	; 6
     9ae:	ec 93       	st	X, r30
				break;
     9b0:	07 c0       	rjmp	.+14     	; 0x9c0 <_ZN9Keyboard_5pressEh+0xe0>
     9b2:	61 e0       	ldi	r22, 0x01	; 1
     9b4:	62 0f       	add	r22, r18
     9b6:	2f 5f       	subi	r18, 0xFF	; 255
     9b8:	3f 4f       	sbci	r19, 0xFF	; 255
	// and if there is an empty slot.
	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
		
		for (i=0; i<6; i++) {
     9ba:	26 30       	cpi	r18, 0x06	; 6
     9bc:	31 05       	cpc	r19, r1
     9be:	31 f7       	brne	.-52     	; 0x98c <_ZN9Keyboard_5pressEh+0xac>
			if (_keyReport.keys[i] == 0x00) {
				_keyReport.keys[i] = k;
				break;
			}
		}
		if (i == 6) {
     9c0:	66 30       	cpi	r22, 0x06	; 6
     9c2:	41 f4       	brne	.+16     	; 0x9d4 <_ZN9Keyboard_5pressEh+0xf4>
     9c4:	21 e0       	ldi	r18, 0x01	; 1
     9c6:	30 e0       	ldi	r19, 0x00	; 0
     9c8:	fc 01       	movw	r30, r24
     9ca:	33 83       	std	Z+3, r19	; 0x03
     9cc:	22 83       	std	Z+2, r18	; 0x02
			setWriteError();
			return 0;
     9ce:	80 e0       	ldi	r24, 0x00	; 0
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	08 95       	ret
		}	
	}
	sendReport(&_keyReport);
     9d4:	bc 01       	movw	r22, r24
     9d6:	6c 5f       	subi	r22, 0xFC	; 252
     9d8:	7f 4f       	sbci	r23, 0xFF	; 255
     9da:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <_ZN9Keyboard_10sendReportEP9KeyReport>
	return 1;
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	90 e0       	ldi	r25, 0x00	; 0
}
     9e2:	08 95       	ret

000009e4 <_ZN9Keyboard_7releaseEh>:
// sends the report.  This tells the OS the key is no longer pressed and that
// it shouldn't be repeated any more.
size_t Keyboard_::release(uint8_t k) 
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
     9e4:	68 38       	cpi	r22, 0x88	; 136
     9e6:	18 f0       	brcs	.+6      	; 0x9ee <_ZN9Keyboard_7releaseEh+0xa>
		k = k - 136;
     9e8:	e8 e7       	ldi	r30, 0x78	; 120
     9ea:	e6 0f       	add	r30, r22
     9ec:	25 c0       	rjmp	.+74     	; 0xa38 <_ZN9Keyboard_7releaseEh+0x54>
	} else if (k >= 128) {	// it's a modifier key
     9ee:	66 23       	and	r22, r22
     9f0:	9c f4       	brge	.+38     	; 0xa18 <_ZN9Keyboard_7releaseEh+0x34>
		_keyReport.modifiers &= ~(1<<(k-128));
     9f2:	60 58       	subi	r22, 0x80	; 128
     9f4:	41 e0       	ldi	r20, 0x01	; 1
     9f6:	50 e0       	ldi	r21, 0x00	; 0
     9f8:	9a 01       	movw	r18, r20
     9fa:	02 c0       	rjmp	.+4      	; 0xa00 <_ZN9Keyboard_7releaseEh+0x1c>
     9fc:	22 0f       	add	r18, r18
     9fe:	33 1f       	adc	r19, r19
     a00:	6a 95       	dec	r22
     a02:	e2 f7       	brpl	.-8      	; 0x9fc <_ZN9Keyboard_7releaseEh+0x18>
     a04:	20 95       	com	r18
     a06:	dc 01       	movw	r26, r24
     a08:	14 96       	adiw	r26, 0x04	; 4
     a0a:	3c 91       	ld	r19, X
     a0c:	14 97       	sbiw	r26, 0x04	; 4
     a0e:	23 23       	and	r18, r19
     a10:	14 96       	adiw	r26, 0x04	; 4
     a12:	2c 93       	st	X, r18
		k = 0;
     a14:	e0 e0       	ldi	r30, 0x00	; 0
     a16:	10 c0       	rjmp	.+32     	; 0xa38 <_ZN9Keyboard_7releaseEh+0x54>
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
     a18:	e6 2f       	mov	r30, r22
     a1a:	f0 e0       	ldi	r31, 0x00	; 0
     a1c:	e2 51       	subi	r30, 0x12	; 18
     a1e:	ff 4f       	sbci	r31, 0xFF	; 255
     a20:	e4 91       	lpm	r30, Z
		if (!k) {
     a22:	ee 23       	and	r30, r30
     a24:	f1 f0       	breq	.+60     	; 0xa62 <_ZN9Keyboard_7releaseEh+0x7e>
			return 0;
		}
		if (k & 0x80) {							// it's a capital letter or other character reached with shift
     a26:	44 f4       	brge	.+16     	; 0xa38 <_ZN9Keyboard_7releaseEh+0x54>
			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
     a28:	dc 01       	movw	r26, r24
     a2a:	14 96       	adiw	r26, 0x04	; 4
     a2c:	2c 91       	ld	r18, X
     a2e:	14 97       	sbiw	r26, 0x04	; 4
     a30:	2d 7f       	andi	r18, 0xFD	; 253
     a32:	14 96       	adiw	r26, 0x04	; 4
     a34:	2c 93       	st	X, r18
			k &= 0x7F;
     a36:	ef 77       	andi	r30, 0x7F	; 127
     a38:	dc 01       	movw	r26, r24
     a3a:	16 96       	adiw	r26, 0x06	; 6
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
		k = k - 136;
	} else if (k >= 128) {	// it's a modifier key
		_keyReport.modifiers &= ~(1<<(k-128));
		k = 0;
     a3c:	36 e0       	ldi	r19, 0x06	; 6
	}
	
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
		if (0 != k && _keyReport.keys[i] == k) {
     a3e:	ee 23       	and	r30, r30
     a40:	21 f0       	breq	.+8      	; 0xa4a <_ZN9Keyboard_7releaseEh+0x66>
     a42:	2c 91       	ld	r18, X
     a44:	2e 13       	cpse	r18, r30
     a46:	01 c0       	rjmp	.+2      	; 0xa4a <_ZN9Keyboard_7releaseEh+0x66>
			_keyReport.keys[i] = 0x00;
     a48:	1c 92       	st	X, r1
     a4a:	31 50       	subi	r19, 0x01	; 1
     a4c:	11 96       	adiw	r26, 0x01	; 1
		}
	}
	
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
     a4e:	31 11       	cpse	r19, r1
     a50:	f6 cf       	rjmp	.-20     	; 0xa3e <_ZN9Keyboard_7releaseEh+0x5a>
		if (0 != k && _keyReport.keys[i] == k) {
			_keyReport.keys[i] = 0x00;
		}
	}

	sendReport(&_keyReport);
     a52:	bc 01       	movw	r22, r24
     a54:	6c 5f       	subi	r22, 0xFC	; 252
     a56:	7f 4f       	sbci	r23, 0xFF	; 255
     a58:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <_ZN9Keyboard_10sendReportEP9KeyReport>
	return 1;
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	08 95       	ret
		_keyReport.modifiers &= ~(1<<(k-128));
		k = 0;
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
		if (!k) {
			return 0;
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	90 e0       	ldi	r25, 0x00	; 0
		}
	}

	sendReport(&_keyReport);
	return 1;
}
     a66:	08 95       	ret

00000a68 <_ZN9Keyboard_10releaseAllEv>:

void Keyboard_::releaseAll(void)
{
     a68:	fc 01       	movw	r30, r24
	_keyReport.keys[0] = 0;
     a6a:	16 82       	std	Z+6, r1	; 0x06
	_keyReport.keys[1] = 0;	
     a6c:	17 82       	std	Z+7, r1	; 0x07
	_keyReport.keys[2] = 0;
     a6e:	10 86       	std	Z+8, r1	; 0x08
	_keyReport.keys[3] = 0;	
     a70:	11 86       	std	Z+9, r1	; 0x09
	_keyReport.keys[4] = 0;
     a72:	12 86       	std	Z+10, r1	; 0x0a
	_keyReport.keys[5] = 0;	
     a74:	13 86       	std	Z+11, r1	; 0x0b
	_keyReport.modifiers = 0;
     a76:	14 82       	std	Z+4, r1	; 0x04
	sendReport(&_keyReport);
     a78:	bc 01       	movw	r22, r24
     a7a:	6c 5f       	subi	r22, 0xFC	; 252
     a7c:	7f 4f       	sbci	r23, 0xFF	; 255
     a7e:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <_ZN9Keyboard_10sendReportEP9KeyReport>
     a82:	08 95       	ret

00000a84 <_GLOBAL__sub_I_Mouse>:

//#define RAWHID_ENABLED

//	Singletons for mouse and keyboard

Mouse_ Mouse;
     a84:	8d e3       	ldi	r24, 0x3D	; 61
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	0e 94 5f 04 	call	0x8be	; 0x8be <_ZN6Mouse_C1Ev>
Keyboard_ Keyboard;
     a8c:	81 e3       	ldi	r24, 0x31	; 49
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	0e 94 62 04 	call	0x8c4	; 0x8c4 <_ZN9Keyboard_C1Ev>
     a94:	08 95       	ret

00000a96 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
     a96:	08 95       	ret

00000a98 <_ZNK9IPAddress7printToER5Print>:
{
    return memcmp(addr, _address.bytes, sizeof(_address.bytes)) == 0;
}

size_t IPAddress::printTo(Print& p) const
{
     a98:	af 92       	push	r10
     a9a:	bf 92       	push	r11
     a9c:	cf 92       	push	r12
     a9e:	df 92       	push	r13
     aa0:	ef 92       	push	r14
     aa2:	ff 92       	push	r15
     aa4:	0f 93       	push	r16
     aa6:	1f 93       	push	r17
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	5c 01       	movw	r10, r24
     aae:	7b 01       	movw	r14, r22
    size_t n = 0;
    for (int i =0; i < 3; i++)
     ab0:	c0 e0       	ldi	r28, 0x00	; 0
     ab2:	d0 e0       	ldi	r29, 0x00	; 0
    return memcmp(addr, _address.bytes, sizeof(_address.bytes)) == 0;
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
     ab4:	00 e0       	ldi	r16, 0x00	; 0
     ab6:	10 e0       	ldi	r17, 0x00	; 0
     ab8:	f5 01       	movw	r30, r10
     aba:	ec 0f       	add	r30, r28
     abc:	fd 1f       	adc	r31, r29
    for (int i =0; i < 3; i++)
    {
        n += p.print(_address.bytes[i], DEC);
     abe:	4a e0       	ldi	r20, 0x0A	; 10
     ac0:	50 e0       	ldi	r21, 0x00	; 0
     ac2:	62 81       	ldd	r22, Z+2	; 0x02
     ac4:	c7 01       	movw	r24, r14
     ac6:	0e 94 99 06 	call	0xd32	; 0xd32 <_ZN5Print5printEhi>
     aca:	6c 01       	movw	r12, r24
        n += p.print('.');
     acc:	6e e2       	ldi	r22, 0x2E	; 46
     ace:	c7 01       	movw	r24, r14
     ad0:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <_ZN5Print5printEc>
size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i =0; i < 3; i++)
    {
        n += p.print(_address.bytes[i], DEC);
     ad4:	8c 0d       	add	r24, r12
     ad6:	9d 1d       	adc	r25, r13
        n += p.print('.');
     ad8:	08 0f       	add	r16, r24
     ada:	19 1f       	adc	r17, r25
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i =0; i < 3; i++)
     adc:	21 96       	adiw	r28, 0x01	; 1
     ade:	c3 30       	cpi	r28, 0x03	; 3
     ae0:	d1 05       	cpc	r29, r1
     ae2:	51 f7       	brne	.-44     	; 0xab8 <_ZNK9IPAddress7printToER5Print+0x20>
    {
        n += p.print(_address.bytes[i], DEC);
        n += p.print('.');
    }
    n += p.print(_address.bytes[3], DEC);
     ae4:	4a e0       	ldi	r20, 0x0A	; 10
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	f5 01       	movw	r30, r10
     aea:	65 81       	ldd	r22, Z+5	; 0x05
     aec:	c7 01       	movw	r24, r14
     aee:	0e 94 99 06 	call	0xd32	; 0xd32 <_ZN5Print5printEhi>
    return n;
}
     af2:	80 0f       	add	r24, r16
     af4:	91 1f       	adc	r25, r17
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	ff 90       	pop	r15
     b00:	ef 90       	pop	r14
     b02:	df 90       	pop	r13
     b04:	cf 90       	pop	r12
     b06:	bf 90       	pop	r11
     b08:	af 90       	pop	r10
     b0a:	08 95       	ret

00000b0c <_ZN9IPAddressC1Ehhhh>:
IPAddress::IPAddress()
{
    _address.dword = 0;
}

IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
     b0c:	0f 93       	push	r16
     b0e:	fc 01       	movw	r30, r24
     b10:	8c e3       	ldi	r24, 0x3C	; 60
     b12:	91 e0       	ldi	r25, 0x01	; 1
     b14:	91 83       	std	Z+1, r25	; 0x01
     b16:	80 83       	st	Z, r24
{
    _address.bytes[0] = first_octet;
     b18:	62 83       	std	Z+2, r22	; 0x02
    _address.bytes[1] = second_octet;
     b1a:	43 83       	std	Z+3, r20	; 0x03
    _address.bytes[2] = third_octet;
     b1c:	24 83       	std	Z+4, r18	; 0x04
    _address.bytes[3] = fourth_octet;
     b1e:	05 83       	std	Z+5, r16	; 0x05
}
     b20:	0f 91       	pop	r16
     b22:	08 95       	ret

00000b24 <_GLOBAL__sub_I__ZN9IPAddressC2Ev>:
        n += p.print(_address.bytes[i], DEC);
        n += p.print('.');
    }
    n += p.print(_address.bytes[3], DEC);
    return n;
}
     b24:	0f 93       	push	r16
    friend class Server;
    friend class DhcpClass;
    friend class DNSClient;
};

const IPAddress INADDR_NONE(0,0,0,0);
     b26:	00 e0       	ldi	r16, 0x00	; 0
     b28:	20 e0       	ldi	r18, 0x00	; 0
     b2a:	40 e0       	ldi	r20, 0x00	; 0
     b2c:	60 e0       	ldi	r22, 0x00	; 0
     b2e:	8e e3       	ldi	r24, 0x3E	; 62
     b30:	92 e0       	ldi	r25, 0x02	; 2
     b32:	0e 94 86 05 	call	0xb0c	; 0xb0c <_ZN9IPAddressC1Ehhhh>
     b36:	0f 91       	pop	r16
     b38:	08 95       	ret

00000b3a <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     b3a:	cf 92       	push	r12
     b3c:	df 92       	push	r13
     b3e:	ef 92       	push	r14
     b40:	ff 92       	push	r15
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	cf 93       	push	r28
     b48:	df 93       	push	r29
     b4a:	6c 01       	movw	r12, r24
  size_t n = 0;
  while (size--) {
     b4c:	41 15       	cp	r20, r1
     b4e:	51 05       	cpc	r21, r1
     b50:	b1 f0       	breq	.+44     	; 0xb7e <_ZN5Print5writeEPKhj+0x44>
     b52:	06 2f       	mov	r16, r22
     b54:	17 2f       	mov	r17, r23
     b56:	ea 01       	movw	r28, r20
// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
     b58:	e1 2c       	mov	r14, r1
     b5a:	f1 2c       	mov	r15, r1
  while (size--) {
    n += write(*buffer++);
     b5c:	d8 01       	movw	r26, r16
     b5e:	6d 91       	ld	r22, X+
     b60:	8d 01       	movw	r16, r26
     b62:	d6 01       	movw	r26, r12
     b64:	ed 91       	ld	r30, X+
     b66:	fc 91       	ld	r31, X
     b68:	01 90       	ld	r0, Z+
     b6a:	f0 81       	ld	r31, Z
     b6c:	e0 2d       	mov	r30, r0
     b6e:	c6 01       	movw	r24, r12
     b70:	09 95       	icall
     b72:	e8 0e       	add	r14, r24
     b74:	f9 1e       	adc	r15, r25
     b76:	21 97       	sbiw	r28, 0x01	; 1

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     b78:	20 97       	sbiw	r28, 0x00	; 0
     b7a:	81 f7       	brne	.-32     	; 0xb5c <_ZN5Print5writeEPKhj+0x22>
     b7c:	02 c0       	rjmp	.+4      	; 0xb82 <_ZN5Print5writeEPKhj+0x48>
// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
     b7e:	e1 2c       	mov	r14, r1
     b80:	f1 2c       	mov	r15, r1
  while (size--) {
    n += write(*buffer++);
  }
  return n;
}
     b82:	c7 01       	movw	r24, r14
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	1f 91       	pop	r17
     b8a:	0f 91       	pop	r16
     b8c:	ff 90       	pop	r15
     b8e:	ef 90       	pop	r14
     b90:	df 90       	pop	r13
     b92:	cf 90       	pop	r12
     b94:	08 95       	ret

00000b96 <_ZN5Print5printEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     b96:	61 15       	cp	r22, r1
     b98:	71 05       	cpc	r23, r1
     b9a:	81 f0       	breq	.+32     	; 0xbbc <_ZN5Print5printEPKc+0x26>
      return write((const uint8_t *)str, strlen(str));
     b9c:	fb 01       	movw	r30, r22
     b9e:	01 90       	ld	r0, Z+
     ba0:	00 20       	and	r0, r0
     ba2:	e9 f7       	brne	.-6      	; 0xb9e <_ZN5Print5printEPKc+0x8>
     ba4:	31 97       	sbiw	r30, 0x01	; 1
     ba6:	af 01       	movw	r20, r30
     ba8:	46 1b       	sub	r20, r22
     baa:	57 0b       	sbc	r21, r23
     bac:	dc 01       	movw	r26, r24
     bae:	ed 91       	ld	r30, X+
     bb0:	fc 91       	ld	r31, X
     bb2:	02 80       	ldd	r0, Z+2	; 0x02
     bb4:	f3 81       	ldd	r31, Z+3	; 0x03
     bb6:	e0 2d       	mov	r30, r0
     bb8:	09 95       	icall
     bba:	08 95       	ret
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	90 e0       	ldi	r25, 0x00	; 0
}

size_t Print::print(const char str[])
{
  return write(str);
}
     bc0:	08 95       	ret

00000bc2 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
     bc2:	dc 01       	movw	r26, r24
     bc4:	ed 91       	ld	r30, X+
     bc6:	fc 91       	ld	r31, X
     bc8:	01 90       	ld	r0, Z+
     bca:	f0 81       	ld	r31, Z
     bcc:	e0 2d       	mov	r30, r0
     bce:	09 95       	icall
}
     bd0:	08 95       	ret

00000bd2 <_ZN5Print7printlnEv>:
{
  return x.printTo(*this);
}

size_t Print::println(void)
{
     bd2:	0f 93       	push	r16
     bd4:	1f 93       	push	r17
     bd6:	cf 93       	push	r28
     bd8:	df 93       	push	r29
     bda:	ec 01       	movw	r28, r24
  size_t n = print('\r');
     bdc:	6d e0       	ldi	r22, 0x0D	; 13
     bde:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <_ZN5Print5printEc>
     be2:	8c 01       	movw	r16, r24
  n += print('\n');
     be4:	6a e0       	ldi	r22, 0x0A	; 10
     be6:	ce 01       	movw	r24, r28
     be8:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <_ZN5Print5printEc>
  return n;
}
     bec:	80 0f       	add	r24, r16
     bee:	91 1f       	adc	r25, r17
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	08 95       	ret

00000bfa <_ZN5Print7printlnEPKc>:
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	ec 01       	movw	r28, r24
  size_t n = print(c);
     c04:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN5Print5printEPKc>
     c08:	8c 01       	movw	r16, r24
  n += println();
     c0a:	ce 01       	movw	r24, r28
     c0c:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <_ZN5Print7printlnEv>
  return n;
}
     c10:	80 0f       	add	r24, r16
     c12:	91 1f       	adc	r25, r17
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	1f 91       	pop	r17
     c1a:	0f 91       	pop	r16
     c1c:	08 95       	ret

00000c1e <_ZN5Print11printNumberEmh>:
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     c1e:	6f 92       	push	r6
     c20:	7f 92       	push	r7
     c22:	8f 92       	push	r8
     c24:	9f 92       	push	r9
     c26:	af 92       	push	r10
     c28:	bf 92       	push	r11
     c2a:	cf 92       	push	r12
     c2c:	df 92       	push	r13
     c2e:	ef 92       	push	r14
     c30:	ff 92       	push	r15
     c32:	0f 93       	push	r16
     c34:	1f 93       	push	r17
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	a1 97       	sbiw	r28, 0x21	; 33
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	6c 01       	movw	r12, r24
     c4c:	74 2e       	mov	r7, r20
     c4e:	35 2f       	mov	r19, r21
     c50:	86 2f       	mov	r24, r22
     c52:	97 2f       	mov	r25, r23
     c54:	62 2e       	mov	r6, r18
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     c56:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     c58:	21 e0       	ldi	r18, 0x01	; 1
     c5a:	26 15       	cp	r18, r6
     c5c:	20 f0       	brcs	.+8      	; 0xc66 <_ZN5Print11printNumberEmh+0x48>
     c5e:	0f 2e       	mov	r0, r31
     c60:	fa e0       	ldi	r31, 0x0A	; 10
     c62:	6f 2e       	mov	r6, r31
     c64:	f0 2d       	mov	r31, r0
     c66:	7e 01       	movw	r14, r28
     c68:	a1 e2       	ldi	r26, 0x21	; 33
     c6a:	ea 0e       	add	r14, r26
     c6c:	f1 1c       	adc	r15, r1

  do {
    unsigned long m = n;
    n /= base;
     c6e:	86 2c       	mov	r8, r6
     c70:	91 2c       	mov	r9, r1
     c72:	a1 2c       	mov	r10, r1
     c74:	b1 2c       	mov	r11, r1
     c76:	67 2d       	mov	r22, r7
     c78:	73 2f       	mov	r23, r19
     c7a:	a5 01       	movw	r20, r10
     c7c:	94 01       	movw	r18, r8
     c7e:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
     c82:	e2 2f       	mov	r30, r18
     c84:	73 2f       	mov	r23, r19
     c86:	02 2f       	mov	r16, r18
     c88:	13 2f       	mov	r17, r19
     c8a:	24 2f       	mov	r18, r20
     c8c:	35 2f       	mov	r19, r21
    char c = m - base * n;
     c8e:	f7 2d       	mov	r31, r7
     c90:	6e 9e       	mul	r6, r30
     c92:	f0 19       	sub	r31, r0
     c94:	11 24       	eor	r1, r1
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     c96:	b1 e0       	ldi	r27, 0x01	; 1
     c98:	eb 1a       	sub	r14, r27
     c9a:	f1 08       	sbc	r15, r1
     c9c:	fa 30       	cpi	r31, 0x0A	; 10
     c9e:	10 f4       	brcc	.+4      	; 0xca4 <_ZN5Print11printNumberEmh+0x86>
     ca0:	f0 5d       	subi	r31, 0xD0	; 208
     ca2:	01 c0       	rjmp	.+2      	; 0xca6 <_ZN5Print11printNumberEmh+0x88>
     ca4:	f9 5c       	subi	r31, 0xC9	; 201
     ca6:	d7 01       	movw	r26, r14
     ca8:	fc 93       	st	X, r31
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
     caa:	01 2b       	or	r16, r17
     cac:	02 2b       	or	r16, r18
     cae:	03 2b       	or	r16, r19
     cb0:	29 f0       	breq	.+10     	; 0xcbc <_ZN5Print11printNumberEmh+0x9e>
    unsigned long m = n;
    n /= base;
     cb2:	7e 2e       	mov	r7, r30
     cb4:	37 2f       	mov	r19, r23
     cb6:	84 2f       	mov	r24, r20
     cb8:	95 2f       	mov	r25, r21
     cba:	dd cf       	rjmp	.-70     	; 0xc76 <_ZN5Print11printNumberEmh+0x58>
     cbc:	e1 14       	cp	r14, r1
     cbe:	f1 04       	cpc	r15, r1
     cc0:	91 f0       	breq	.+36     	; 0xce6 <_ZN5Print11printNumberEmh+0xc8>
      return write((const uint8_t *)str, strlen(str));
     cc2:	f7 01       	movw	r30, r14
     cc4:	01 90       	ld	r0, Z+
     cc6:	00 20       	and	r0, r0
     cc8:	e9 f7       	brne	.-6      	; 0xcc4 <_ZN5Print11printNumberEmh+0xa6>
     cca:	31 97       	sbiw	r30, 0x01	; 1
     ccc:	af 01       	movw	r20, r30
     cce:	4e 19       	sub	r20, r14
     cd0:	5f 09       	sbc	r21, r15
     cd2:	d6 01       	movw	r26, r12
     cd4:	ed 91       	ld	r30, X+
     cd6:	fc 91       	ld	r31, X
     cd8:	02 80       	ldd	r0, Z+2	; 0x02
     cda:	f3 81       	ldd	r31, Z+3	; 0x03
     cdc:	e0 2d       	mov	r30, r0
     cde:	b7 01       	movw	r22, r14
     ce0:	c6 01       	movw	r24, r12
     ce2:	09 95       	icall
     ce4:	02 c0       	rjmp	.+4      	; 0xcea <_ZN5Print11printNumberEmh+0xcc>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	90 e0       	ldi	r25, 0x00	; 0
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
}
     cea:	a1 96       	adiw	r28, 0x21	; 33
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	de bf       	out	0x3e, r29	; 62
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	ff 90       	pop	r15
     d00:	ef 90       	pop	r14
     d02:	df 90       	pop	r13
     d04:	cf 90       	pop	r12
     d06:	bf 90       	pop	r11
     d08:	af 90       	pop	r10
     d0a:	9f 90       	pop	r9
     d0c:	8f 90       	pop	r8
     d0e:	7f 90       	pop	r7
     d10:	6f 90       	pop	r6
     d12:	08 95       	ret

00000d14 <_ZN5Print5printEmi>:
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
     d14:	21 15       	cp	r18, r1
     d16:	31 05       	cpc	r19, r1
     d18:	49 f4       	brne	.+18     	; 0xd2c <_ZN5Print5printEmi+0x18>
     d1a:	dc 01       	movw	r26, r24
     d1c:	ed 91       	ld	r30, X+
     d1e:	fc 91       	ld	r31, X
     d20:	01 90       	ld	r0, Z+
     d22:	f0 81       	ld	r31, Z
     d24:	e0 2d       	mov	r30, r0
     d26:	64 2f       	mov	r22, r20
     d28:	09 95       	icall
     d2a:	08 95       	ret
  else return printNumber(n, base);
     d2c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <_ZN5Print11printNumberEmh>
}
     d30:	08 95       	ret

00000d32 <_ZN5Print5printEhi>:
{
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
     d32:	9a 01       	movw	r18, r20
  return print((unsigned long) b, base);
     d34:	46 2f       	mov	r20, r22
     d36:	50 e0       	ldi	r21, 0x00	; 0
     d38:	60 e0       	ldi	r22, 0x00	; 0
     d3a:	70 e0       	ldi	r23, 0x00	; 0
     d3c:	0e 94 8a 06 	call	0xd14	; 0xd14 <_ZN5Print5printEmi>
}
     d40:	08 95       	ret

00000d42 <_ZL11SendControlh>:
}

static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
     d42:	40 91 47 02 	lds	r20, 0x0247
     d46:	50 91 48 02 	lds	r21, 0x0248
     d4a:	20 91 45 02 	lds	r18, 0x0245
     d4e:	30 91 46 02 	lds	r19, 0x0246
     d52:	42 17       	cp	r20, r18
     d54:	53 07       	cpc	r21, r19
     d56:	bc f4       	brge	.+46     	; 0xd86 <_ZL11SendControlh+0x44>
		;
}

static inline u8 WaitForINOrOUT()
{
	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
     d58:	e8 ee       	ldi	r30, 0xE8	; 232
     d5a:	f0 e0       	ldi	r31, 0x00	; 0
     d5c:	90 81       	ld	r25, Z
     d5e:	95 70       	andi	r25, 0x05	; 5
     d60:	e9 f3       	breq	.-6      	; 0xd5c <_ZL11SendControlh+0x1a>
		;
	return (UEINTX & (1<<RXOUTI)) == 0;
     d62:	90 91 e8 00 	lds	r25, 0x00E8
static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
     d66:	92 fd       	sbrc	r25, 2
     d68:	19 c0       	rjmp	.+50     	; 0xd9c <_ZL11SendControlh+0x5a>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     d6a:	80 93 f1 00 	sts	0x00F1, r24
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
     d6e:	80 91 47 02 	lds	r24, 0x0247
     d72:	90 91 48 02 	lds	r25, 0x0248
     d76:	01 96       	adiw	r24, 0x01	; 1
     d78:	8f 73       	andi	r24, 0x3F	; 63
     d7a:	99 27       	eor	r25, r25
     d7c:	89 2b       	or	r24, r25
     d7e:	19 f4       	brne	.+6      	; 0xd86 <_ZL11SendControlh+0x44>
		;
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
     d80:	8e ef       	ldi	r24, 0xFE	; 254
     d82:	80 93 e8 00 	sts	0x00E8, r24
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
	_cmark++;
     d86:	80 91 47 02 	lds	r24, 0x0247
     d8a:	90 91 48 02 	lds	r25, 0x0248
     d8e:	01 96       	adiw	r24, 0x01	; 1
     d90:	90 93 48 02 	sts	0x0248, r25
     d94:	80 93 47 02 	sts	0x0247, r24
	return true;
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	08 95       	ret
bool SendControl(u8 d)
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
     d9c:	80 e0       	ldi	r24, 0x00	; 0
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
	_cmark++;
	return true;
};
     d9e:	08 95       	ret

00000da0 <_ZL24USB_SendStringDescriptorPKhh>:
}

// Send a USB descriptor string. The string is stored in PROGMEM as a
// plain ASCII string but is sent out as UTF-16 with the correct 2-byte
// prefix
static bool USB_SendStringDescriptor(const u8*string_P, u8 string_len) {
     da0:	ff 92       	push	r15
     da2:	0f 93       	push	r16
     da4:	1f 93       	push	r17
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
     daa:	08 2f       	mov	r16, r24
     dac:	19 2f       	mov	r17, r25
     dae:	f6 2e       	mov	r15, r22
        SendControl(2 + string_len * 2);
     db0:	86 2f       	mov	r24, r22
     db2:	88 0f       	add	r24, r24
     db4:	8e 5f       	subi	r24, 0xFE	; 254
     db6:	0e 94 a1 06 	call	0xd42	; 0xd42 <_ZL11SendControlh>
        SendControl(3);
     dba:	83 e0       	ldi	r24, 0x03	; 3
     dbc:	0e 94 a1 06 	call	0xd42	; 0xd42 <_ZL11SendControlh>
        for(u8 i = 0; i < string_len; i++) {
     dc0:	ff 20       	and	r15, r15
     dc2:	91 f0       	breq	.+36     	; 0xde8 <_ZL24USB_SendStringDescriptorPKhh+0x48>
     dc4:	c0 2f       	mov	r28, r16
     dc6:	d1 2f       	mov	r29, r17
     dc8:	10 e0       	ldi	r17, 0x00	; 0
                bool r = SendControl(pgm_read_byte(&string_P[i]));
     dca:	fe 01       	movw	r30, r28
     dcc:	84 91       	lpm	r24, Z
     dce:	0e 94 a1 06 	call	0xd42	; 0xd42 <_ZL11SendControlh>
     dd2:	08 2f       	mov	r16, r24
                r &= SendControl(0); // high byte
     dd4:	80 e0       	ldi	r24, 0x00	; 0
     dd6:	0e 94 a1 06 	call	0xd42	; 0xd42 <_ZL11SendControlh>
     dda:	80 23       	and	r24, r16
                if(!r) {
     ddc:	31 f0       	breq	.+12     	; 0xdea <_ZL24USB_SendStringDescriptorPKhh+0x4a>
// plain ASCII string but is sent out as UTF-16 with the correct 2-byte
// prefix
static bool USB_SendStringDescriptor(const u8*string_P, u8 string_len) {
        SendControl(2 + string_len * 2);
        SendControl(3);
        for(u8 i = 0; i < string_len; i++) {
     dde:	1f 5f       	subi	r17, 0xFF	; 255
     de0:	21 96       	adiw	r28, 0x01	; 1
     de2:	1f 11       	cpse	r17, r15
     de4:	f2 cf       	rjmp	.-28     	; 0xdca <_ZL24USB_SendStringDescriptorPKhh+0x2a>
     de6:	01 c0       	rjmp	.+2      	; 0xdea <_ZL24USB_SendStringDescriptorPKhh+0x4a>
                r &= SendControl(0); // high byte
                if(!r) {
                        return false;
                }
        }
        return true;
     de8:	81 e0       	ldi	r24, 0x01	; 1
}
     dea:	df 91       	pop	r29
     dec:	cf 91       	pop	r28
     dee:	1f 91       	pop	r17
     df0:	0f 91       	pop	r16
     df2:	ff 90       	pop	r15
     df4:	08 95       	ret

00000df6 <_Z4RecvPVhh>:
{
	UEINTX = ~(1<<RXOUTI);
}

void Recv(volatile u8* data, u8 count)
{
     df6:	fc 01       	movw	r30, r24
	while (count--)
     df8:	2f ef       	ldi	r18, 0xFF	; 255
     dfa:	26 0f       	add	r18, r22
     dfc:	66 23       	and	r22, r22
     dfe:	51 f0       	breq	.+20     	; 0xe14 <_Z4RecvPVhh+0x1e>
		*data++ = UEDATX;
     e00:	a1 ef       	ldi	r26, 0xF1	; 241
     e02:	b0 e0       	ldi	r27, 0x00	; 0
     e04:	cf 01       	movw	r24, r30
     e06:	01 96       	adiw	r24, 0x01	; 1
     e08:	3c 91       	ld	r19, X
     e0a:	30 83       	st	Z, r19
	UEINTX = ~(1<<RXOUTI);
}

void Recv(volatile u8* data, u8 count)
{
	while (count--)
     e0c:	21 50       	subi	r18, 0x01	; 1
     e0e:	10 f0       	brcs	.+4      	; 0xe14 <_Z4RecvPVhh+0x1e>
		*data++ = UEDATX;
     e10:	fc 01       	movw	r30, r24
     e12:	f8 cf       	rjmp	.-16     	; 0xe04 <_Z4RecvPVhh+0xe>
	
	RXLED1;					// light the RX LED
     e14:	28 98       	cbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
     e16:	84 e6       	ldi	r24, 0x64	; 100
     e18:	80 93 4a 02 	sts	0x024A, r24
     e1c:	08 95       	ret

00000e1e <_Z13USB_Availableh>:
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     e1e:	9f b7       	in	r25, 0x3f	; 63
	{
		cli();
     e20:	f8 94       	cli
		SetEP(ep & 7);
     e22:	87 70       	andi	r24, 0x07	; 7
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     e24:	80 93 e9 00 	sts	0x00E9, r24
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     e28:	80 91 f2 00 	lds	r24, 0x00F2
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     e2c:	9f bf       	out	0x3f, r25	; 63
//	Number of bytes, assumes a rx endpoint
u8 USB_Available(u8 ep)
{
	LockEP lock(ep);
	return FifoByteCount();
}
     e2e:	08 95       	ret

00000e30 <_Z8USB_RecvhPvi>:

//	Non Blocking receive
//	Return number of bytes read
int USB_Recv(u8 ep, void* d, int len)
{
	if (!_usbConfiguration || len < 0)
     e30:	90 91 49 02 	lds	r25, 0x0249
     e34:	99 23       	and	r25, r25
     e36:	59 f1       	breq	.+86     	; 0xe8e <_Z8USB_RecvhPvi+0x5e>
     e38:	55 23       	and	r21, r21
     e3a:	64 f1       	brlt	.+88     	; 0xe94 <_Z8USB_RecvhPvi+0x64>
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     e3c:	2f b7       	in	r18, 0x3f	; 63
	{
		cli();
     e3e:	f8 94       	cli
		SetEP(ep & 7);
     e40:	87 70       	andi	r24, 0x07	; 7
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     e42:	80 93 e9 00 	sts	0x00E9, r24
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     e46:	80 91 f2 00 	lds	r24, 0x00F2
	if (!_usbConfiguration || len < 0)
		return -1;
	
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	84 17       	cp	r24, r20
     e4e:	95 07       	cpc	r25, r21
     e50:	0c f4       	brge	.+2      	; 0xe54 <_Z8USB_RecvhPvi+0x24>
     e52:	ac 01       	movw	r20, r24
	n = len;
	u8* dst = (u8*)d;
	while (n--)
     e54:	44 23       	and	r20, r20
     e56:	69 f0       	breq	.+26     	; 0xe72 <_Z8USB_RecvhPvi+0x42>
     e58:	e6 2f       	mov	r30, r22
     e5a:	f7 2f       	mov	r31, r23
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;
     e5c:	94 e6       	ldi	r25, 0x64	; 100

	return UEDATX;	
     e5e:	a1 ef       	ldi	r26, 0xF1	; 241
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	64 0f       	add	r22, r20
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
     e64:	28 98       	cbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;
     e66:	90 93 4a 02 	sts	0x024A, r25

	return UEDATX;	
     e6a:	8c 91       	ld	r24, X
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
     e6c:	81 93       	st	Z+, r24
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
     e6e:	6e 13       	cpse	r22, r30
     e70:	f9 cf       	rjmp	.-14     	; 0xe64 <_Z8USB_RecvhPvi+0x34>
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
     e72:	41 15       	cp	r20, r1
     e74:	51 05       	cpc	r21, r1
     e76:	39 f0       	breq	.+14     	; 0xe86 <_Z8USB_RecvhPvi+0x56>
	UENUM = ep;
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     e78:	80 91 f2 00 	lds	r24, 0x00F2
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
     e7c:	81 11       	cpse	r24, r1
     e7e:	03 c0       	rjmp	.+6      	; 0xe86 <_Z8USB_RecvhPvi+0x56>
	return UEINTX & (1<<FIFOCON);
}

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
     e80:	8b e6       	ldi	r24, 0x6B	; 107
     e82:	80 93 e8 00 	sts	0x00E8, r24
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     e86:	2f bf       	out	0x3f, r18	; 63
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
	
	return len;
     e88:	84 2f       	mov	r24, r20
     e8a:	95 2f       	mov	r25, r21
     e8c:	08 95       	ret
//	Non Blocking receive
//	Return number of bytes read
int USB_Recv(u8 ep, void* d, int len)
{
	if (!_usbConfiguration || len < 0)
		return -1;
     e8e:	8f ef       	ldi	r24, 0xFF	; 255
     e90:	9f ef       	ldi	r25, 0xFF	; 255
     e92:	08 95       	ret
     e94:	8f ef       	ldi	r24, 0xFF	; 255
     e96:	9f ef       	ldi	r25, 0xFF	; 255
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
	
	return len;
}
     e98:	08 95       	ret

00000e9a <_Z8USB_Recvh>:

//	Recv 1 byte if ready
int USB_Recv(u8 ep)
{
     e9a:	cf 93       	push	r28
     e9c:	df 93       	push	r29
     e9e:	1f 92       	push	r1
     ea0:	cd b7       	in	r28, 0x3d	; 61
     ea2:	de b7       	in	r29, 0x3e	; 62
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
     ea4:	41 e0       	ldi	r20, 0x01	; 1
     ea6:	50 e0       	ldi	r21, 0x00	; 0
     ea8:	be 01       	movw	r22, r28
     eaa:	6f 5f       	subi	r22, 0xFF	; 255
     eac:	7f 4f       	sbci	r23, 0xFF	; 255
     eae:	0e 94 18 07 	call	0xe30	; 0xe30 <_Z8USB_RecvhPvi>
     eb2:	01 97       	sbiw	r24, 0x01	; 1
     eb4:	19 f4       	brne	.+6      	; 0xebc <_Z8USB_Recvh+0x22>
		return -1;
	return c;
     eb6:	89 81       	ldd	r24, Y+1	; 0x01
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	02 c0       	rjmp	.+4      	; 0xec0 <_Z8USB_Recvh+0x26>
//	Recv 1 byte if ready
int USB_Recv(u8 ep)
{
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
		return -1;
     ebc:	8f ef       	ldi	r24, 0xFF	; 255
     ebe:	9f ef       	ldi	r25, 0xFF	; 255
	return c;
}
     ec0:	0f 90       	pop	r0
     ec2:	df 91       	pop	r29
     ec4:	cf 91       	pop	r28
     ec6:	08 95       	ret

00000ec8 <_Z13USB_SendSpaceh>:
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     ec8:	2f b7       	in	r18, 0x3f	; 63
	{
		cli();
     eca:	f8 94       	cli
		SetEP(ep & 7);
     ecc:	87 70       	andi	r24, 0x07	; 7
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     ece:	80 93 e9 00 	sts	0x00E9, r24
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
     ed2:	90 91 e8 00 	lds	r25, 0x00E8

//	Space in send EP
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
     ed6:	89 2f       	mov	r24, r25
     ed8:	80 72       	andi	r24, 0x20	; 32
     eda:	95 ff       	sbrs	r25, 5
     edc:	04 c0       	rjmp	.+8      	; 0xee6 <_Z13USB_SendSpaceh+0x1e>
	UENUM = ep;
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     ede:	90 91 f2 00 	lds	r25, 0x00F2
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
     ee2:	80 e4       	ldi	r24, 0x40	; 64
     ee4:	89 1b       	sub	r24, r25
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     ee6:	2f bf       	out	0x3f, r18	; 63
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
}
     ee8:	08 95       	ret

00000eea <_Z8USB_SendhPKvi>:

//	Blocking Send of data to an endpoint
int USB_Send(u8 ep, const void* d, int len)
{
     eea:	2f 92       	push	r2
     eec:	3f 92       	push	r3
     eee:	4f 92       	push	r4
     ef0:	5f 92       	push	r5
     ef2:	6f 92       	push	r6
     ef4:	7f 92       	push	r7
     ef6:	8f 92       	push	r8
     ef8:	9f 92       	push	r9
     efa:	af 92       	push	r10
     efc:	bf 92       	push	r11
     efe:	cf 92       	push	r12
     f00:	df 92       	push	r13
     f02:	ef 92       	push	r14
     f04:	ff 92       	push	r15
     f06:	0f 93       	push	r16
     f08:	1f 93       	push	r17
     f0a:	cf 93       	push	r28
     f0c:	df 93       	push	r29
     f0e:	68 2e       	mov	r6, r24
     f10:	5b 01       	movw	r10, r22
     f12:	4a 01       	movw	r8, r20
	if (!_usbConfiguration)
     f14:	80 91 49 02 	lds	r24, 0x0249
     f18:	88 23       	and	r24, r24
     f1a:	09 f4       	brne	.+2      	; 0xf1e <_Z8USB_SendhPKvi+0x34>
     f1c:	86 c0       	rjmp	.+268    	; 0x102a <_Z8USB_SendhPKvi+0x140>
		return -1;

	int r = len;
	const u8* data = (const u8*)d;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
     f1e:	41 15       	cp	r20, r1
     f20:	51 05       	cpc	r21, r1
     f22:	09 f4       	brne	.+2      	; 0xf26 <_Z8USB_SendhPKvi+0x3c>
     f24:	7b c0       	rjmp	.+246    	; 0x101c <_Z8USB_SendhPKvi+0x132>
     f26:	8a 01       	movw	r16, r20
     f28:	0f 2e       	mov	r0, r31
     f2a:	fa ef       	ldi	r31, 0xFA	; 250
     f2c:	7f 2e       	mov	r7, r31
     f2e:	f0 2d       	mov	r31, r0
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
	{
		cli();
		SetEP(ep & 7);
     f30:	86 2d       	mov	r24, r6
     f32:	87 70       	andi	r24, 0x07	; 7
     f34:	58 2e       	mov	r5, r24
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     f36:	0f 2e       	mov	r0, r31
     f38:	f9 ee       	ldi	r31, 0xE9	; 233
     f3a:	cf 2e       	mov	r12, r31
     f3c:	d1 2c       	mov	r13, r1
     f3e:	f0 2d       	mov	r31, r0
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
     f40:	0f 2e       	mov	r0, r31
     f42:	f8 ee       	ldi	r31, 0xE8	; 232
     f44:	ef 2e       	mov	r14, r31
     f46:	f1 2c       	mov	r15, r1
     f48:	f0 2d       	mov	r31, r0
			LockEP lock(ep);
			// Frame may have been released by the SOF interrupt handler
			if (!ReadWriteAllowed())
				continue;
			len -= n;
			if (ep & TRANSFER_ZERO)
     f4a:	e6 2d       	mov	r30, r6
     f4c:	e0 72       	andi	r30, 0x20	; 32
     f4e:	4e 2e       	mov	r4, r30
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
     f50:	0f 2e       	mov	r0, r31
     f52:	fa e3       	ldi	r31, 0x3A	; 58
     f54:	3f 2e       	mov	r3, r31
     f56:	f0 2d       	mov	r31, r0
			else
			{
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
     f58:	f6 2d       	mov	r31, r6
     f5a:	f0 74       	andi	r31, 0x40	; 64
     f5c:	2f 2e       	mov	r2, r31
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     f5e:	c1 ef       	ldi	r28, 0xF1	; 241
     f60:	d0 e0       	ldi	r29, 0x00	; 0
	int r = len;
	const u8* data = (const u8*)d;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
	{
		u8 n = USB_SendSpace(ep);
     f62:	86 2d       	mov	r24, r6
     f64:	0e 94 64 07 	call	0xec8	; 0xec8 <_Z13USB_SendSpaceh>
		if (n == 0)
     f68:	81 11       	cpse	r24, r1
     f6a:	0a c0       	rjmp	.+20     	; 0xf80 <_Z8USB_SendhPKvi+0x96>
		{
			if (!(--timeout))
     f6c:	7a 94       	dec	r7
     f6e:	09 f4       	brne	.+2      	; 0xf72 <_Z8USB_SendhPKvi+0x88>
     f70:	5f c0       	rjmp	.+190    	; 0x1030 <_Z8USB_SendhPKvi+0x146>
				return -1;
			delay(1);
     f72:	61 e0       	ldi	r22, 0x01	; 1
     f74:	70 e0       	ldi	r23, 0x00	; 0
     f76:	80 e0       	ldi	r24, 0x00	; 0
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	0e 94 cd 0b 	call	0x179a	; 0x179a <delay>
			continue;
     f7e:	4a c0       	rjmp	.+148    	; 0x1014 <_Z8USB_SendhPKvi+0x12a>
		}

		if (n > len)
     f80:	28 2f       	mov	r18, r24
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	02 17       	cp	r16, r18
     f86:	13 07       	cpc	r17, r19
     f88:	0c f4       	brge	.+2      	; 0xf8c <_Z8USB_SendhPKvi+0xa2>
			n = len;
     f8a:	80 2f       	mov	r24, r16
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     f8c:	2f b7       	in	r18, 0x3f	; 63
	{
		cli();
     f8e:	f8 94       	cli
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     f90:	f6 01       	movw	r30, r12
     f92:	50 82       	st	Z, r5
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
     f94:	f7 01       	movw	r30, r14
     f96:	90 81       	ld	r25, Z
		if (n > len)
			n = len;
		{
			LockEP lock(ep);
			// Frame may have been released by the SOF interrupt handler
			if (!ReadWriteAllowed())
     f98:	95 ff       	sbrs	r25, 5
     f9a:	3b c0       	rjmp	.+118    	; 0x1012 <_Z8USB_SendhPKvi+0x128>
				continue;
			len -= n;
     f9c:	08 1b       	sub	r16, r24
     f9e:	11 09       	sbc	r17, r1
			if (ep & TRANSFER_ZERO)
     fa0:	44 20       	and	r4, r4
     fa2:	41 f0       	breq	.+16     	; 0xfb4 <_Z8USB_SendhPKvi+0xca>
			{
				while (n--)
     fa4:	9f ef       	ldi	r25, 0xFF	; 255
     fa6:	98 0f       	add	r25, r24
     fa8:	88 23       	and	r24, r24
     faa:	41 f1       	breq	.+80     	; 0xffc <_Z8USB_SendhPKvi+0x112>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     fac:	18 82       	st	Y, r1
			if (!ReadWriteAllowed())
				continue;
			len -= n;
			if (ep & TRANSFER_ZERO)
			{
				while (n--)
     fae:	91 50       	subi	r25, 0x01	; 1
     fb0:	e8 f7       	brcc	.-6      	; 0xfac <_Z8USB_SendhPKvi+0xc2>
     fb2:	24 c0       	rjmp	.+72     	; 0xffc <_Z8USB_SendhPKvi+0x112>
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
     fb4:	66 20       	and	r6, r6
     fb6:	2c f0       	brlt	.+10     	; 0xfc2 <_Z8USB_SendhPKvi+0xd8>
				while (n--)
					Send8(pgm_read_byte(data++));
			}
			else
			{
				while (n--)
     fb8:	4f ef       	ldi	r20, 0xFF	; 255
     fba:	48 0f       	add	r20, r24
     fbc:	81 11       	cpse	r24, r1
     fbe:	13 c0       	rjmp	.+38     	; 0xfe6 <_Z8USB_SendhPKvi+0xfc>
     fc0:	1d c0       	rjmp	.+58     	; 0xffc <_Z8USB_SendhPKvi+0x112>
				while (n--)
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
			{
				while (n--)
     fc2:	4f ef       	ldi	r20, 0xFF	; 255
     fc4:	48 0f       	add	r20, r24
     fc6:	88 23       	and	r24, r24
     fc8:	c9 f0       	breq	.+50     	; 0xffc <_Z8USB_SendhPKvi+0x112>
     fca:	f5 01       	movw	r30, r10
     fcc:	94 2f       	mov	r25, r20
					Send8(pgm_read_byte(data++));
     fce:	34 91       	lpm	r19, Z
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     fd0:	38 83       	st	Y, r19
				while (n--)
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
			{
				while (n--)
     fd2:	91 50       	subi	r25, 0x01	; 1
     fd4:	31 96       	adiw	r30, 0x01	; 1
     fd6:	9f 3f       	cpi	r25, 0xFF	; 255
     fd8:	d1 f7       	brne	.-12     	; 0xfce <_Z8USB_SendhPKvi+0xe4>
     fda:	84 2f       	mov	r24, r20
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	01 96       	adiw	r24, 0x01	; 1
     fe0:	a8 0e       	add	r10, r24
     fe2:	b9 1e       	adc	r11, r25
     fe4:	0b c0       	rjmp	.+22     	; 0xffc <_Z8USB_SendhPKvi+0x112>
     fe6:	f5 01       	movw	r30, r10
					Send8(pgm_read_byte(data++));
			}
			else
			{
				while (n--)
     fe8:	94 2f       	mov	r25, r20
					Send8(*data++);
     fea:	31 91       	ld	r19, Z+
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     fec:	38 83       	st	Y, r19
				while (n--)
					Send8(pgm_read_byte(data++));
			}
			else
			{
				while (n--)
     fee:	91 50       	subi	r25, 0x01	; 1
     ff0:	e0 f7       	brcc	.-8      	; 0xfea <_Z8USB_SendhPKvi+0x100>
     ff2:	84 2f       	mov	r24, r20
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	01 96       	adiw	r24, 0x01	; 1
     ff8:	a8 0e       	add	r10, r24
     ffa:	b9 1e       	adc	r11, r25
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
     ffc:	f7 01       	movw	r30, r14
     ffe:	80 81       	ld	r24, Z
			else
			{
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
    1000:	85 ff       	sbrs	r24, 5
    1002:	19 c0       	rjmp	.+50     	; 0x1036 <_Z8USB_SendhPKvi+0x14c>
    1004:	01 15       	cp	r16, r1
    1006:	11 05       	cpc	r17, r1
    1008:	11 f4       	brne	.+4      	; 0x100e <_Z8USB_SendhPKvi+0x124>
    100a:	21 10       	cpse	r2, r1
    100c:	14 c0       	rjmp	.+40     	; 0x1036 <_Z8USB_SendhPKvi+0x14c>
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
    100e:	2f bf       	out	0x3f, r18	; 63
    1010:	01 c0       	rjmp	.+2      	; 0x1014 <_Z8USB_SendhPKvi+0x12a>
    1012:	2f bf       	out	0x3f, r18	; 63
		return -1;

	int r = len;
	const u8* data = (const u8*)d;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
    1014:	01 15       	cp	r16, r1
    1016:	11 05       	cpc	r17, r1
    1018:	09 f0       	breq	.+2      	; 0x101c <_Z8USB_SendhPKvi+0x132>
    101a:	a3 cf       	rjmp	.-186    	; 0xf62 <_Z8USB_SendhPKvi+0x78>
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
				ReleaseTX();
		}
	}
	TXLED1;					// light the TX LED
    101c:	5d 98       	cbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
    101e:	84 e6       	ldi	r24, 0x64	; 100
    1020:	80 93 4b 02 	sts	0x024B, r24
	return r;
    1024:	88 2d       	mov	r24, r8
    1026:	99 2d       	mov	r25, r9
    1028:	09 c0       	rjmp	.+18     	; 0x103c <_Z8USB_SendhPKvi+0x152>

//	Blocking Send of data to an endpoint
int USB_Send(u8 ep, const void* d, int len)
{
	if (!_usbConfiguration)
		return -1;
    102a:	8f ef       	ldi	r24, 0xFF	; 255
    102c:	9f ef       	ldi	r25, 0xFF	; 255
    102e:	06 c0       	rjmp	.+12     	; 0x103c <_Z8USB_SendhPKvi+0x152>
	{
		u8 n = USB_SendSpace(ep);
		if (n == 0)
		{
			if (!(--timeout))
				return -1;
    1030:	8f ef       	ldi	r24, 0xFF	; 255
    1032:	9f ef       	ldi	r25, 0xFF	; 255
    1034:	03 c0       	rjmp	.+6      	; 0x103c <_Z8USB_SendhPKvi+0x152>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
    1036:	f7 01       	movw	r30, r14
    1038:	30 82       	st	Z, r3
    103a:	e9 cf       	rjmp	.-46     	; 0x100e <_Z8USB_SendhPKvi+0x124>
		}
	}
	TXLED1;					// light the TX LED
	TxLEDPulse = TX_RX_LED_PULSE_MS;
	return r;
}
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	1f 91       	pop	r17
    1042:	0f 91       	pop	r16
    1044:	ff 90       	pop	r15
    1046:	ef 90       	pop	r14
    1048:	df 90       	pop	r13
    104a:	cf 90       	pop	r12
    104c:	bf 90       	pop	r11
    104e:	af 90       	pop	r10
    1050:	9f 90       	pop	r9
    1052:	8f 90       	pop	r8
    1054:	7f 90       	pop	r7
    1056:	6f 90       	pop	r6
    1058:	5f 90       	pop	r5
    105a:	4f 90       	pop	r4
    105c:	3f 90       	pop	r3
    105e:	2f 90       	pop	r2
    1060:	08 95       	ret

00001062 <_Z11InitControli>:
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    1062:	10 92 e9 00 	sts	0x00E9, r1
int _cmark;
int _cend;
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
    1066:	10 92 48 02 	sts	0x0248, r1
    106a:	10 92 47 02 	sts	0x0247, r1
	_cend = end;
    106e:	90 93 46 02 	sts	0x0246, r25
    1072:	80 93 45 02 	sts	0x0245, r24
    1076:	08 95       	ret

00001078 <_Z15USB_SendControlhPKvi>:
	return true;
};

//	Clipped by _cmark/_cend
int USB_SendControl(u8 flags, const void* d, int len)
{
    1078:	bf 92       	push	r11
    107a:	cf 92       	push	r12
    107c:	df 92       	push	r13
    107e:	ef 92       	push	r14
    1080:	ff 92       	push	r15
    1082:	0f 93       	push	r16
    1084:	1f 93       	push	r17
    1086:	cf 93       	push	r28
    1088:	df 93       	push	r29
    108a:	b4 2e       	mov	r11, r20
    108c:	c5 2e       	mov	r12, r21
	int sent = len;
	const u8* data = (const u8*)d;
	bool pgm = flags & TRANSFER_PGM;
    108e:	d8 2e       	mov	r13, r24
    1090:	e4 2e       	mov	r14, r20
    1092:	f5 2e       	mov	r15, r21
	while (len--)
    1094:	c6 2f       	mov	r28, r22
    1096:	d7 2f       	mov	r29, r23
    1098:	00 e0       	ldi	r16, 0x00	; 0
    109a:	10 e0       	ldi	r17, 0x00	; 0
    109c:	0d c0       	rjmp	.+26     	; 0x10b8 <_Z15USB_SendControlhPKvi+0x40>
	{
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
    109e:	dd 20       	and	r13, r13
    10a0:	1c f4       	brge	.+6      	; 0x10a8 <_Z15USB_SendControlhPKvi+0x30>
    10a2:	fe 01       	movw	r30, r28
    10a4:	84 91       	lpm	r24, Z
    10a6:	01 c0       	rjmp	.+2      	; 0x10aa <_Z15USB_SendControlhPKvi+0x32>
    10a8:	88 81       	ld	r24, Y
		if (!SendControl(c))
    10aa:	0e 94 a1 06 	call	0xd42	; 0xd42 <_ZL11SendControlh>
    10ae:	0f 5f       	subi	r16, 0xFF	; 255
    10b0:	1f 4f       	sbci	r17, 0xFF	; 255
    10b2:	21 96       	adiw	r28, 0x01	; 1
    10b4:	88 23       	and	r24, r24
    10b6:	31 f0       	breq	.+12     	; 0x10c4 <_Z15USB_SendControlhPKvi+0x4c>
int USB_SendControl(u8 flags, const void* d, int len)
{
	int sent = len;
	const u8* data = (const u8*)d;
	bool pgm = flags & TRANSFER_PGM;
	while (len--)
    10b8:	0e 15       	cp	r16, r14
    10ba:	1f 05       	cpc	r17, r15
    10bc:	81 f7       	brne	.-32     	; 0x109e <_Z15USB_SendControlhPKvi+0x26>
	{
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
		if (!SendControl(c))
			return -1;
	}
	return sent;
    10be:	8b 2d       	mov	r24, r11
    10c0:	9c 2d       	mov	r25, r12
    10c2:	02 c0       	rjmp	.+4      	; 0x10c8 <_Z15USB_SendControlhPKvi+0x50>
	bool pgm = flags & TRANSFER_PGM;
	while (len--)
	{
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
		if (!SendControl(c))
			return -1;
    10c4:	8f ef       	ldi	r24, 0xFF	; 255
    10c6:	9f ef       	ldi	r25, 0xFF	; 255
	}
	return sent;
}
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	1f 91       	pop	r17
    10ce:	0f 91       	pop	r16
    10d0:	ff 90       	pop	r15
    10d2:	ef 90       	pop	r14
    10d4:	df 90       	pop	r13
    10d6:	cf 90       	pop	r12
    10d8:	bf 90       	pop	r11
    10da:	08 95       	ret

000010dc <_Z15USB_RecvControlPvi>:

//	Does not timeout or cross fifo boundaries
//	Will only work for transfers <= 64 bytes
//	TODO
int USB_RecvControl(void* d, int len)
{
    10dc:	cf 93       	push	r28
    10de:	df 93       	push	r29
    10e0:	c6 2f       	mov	r28, r22
    10e2:	d7 2f       	mov	r29, r23
	UEINTX = ~(1<<TXINI);
}

static inline void WaitOUT(void)
{
	while (!(UEINTX & (1<<RXOUTI)))
    10e4:	e8 ee       	ldi	r30, 0xE8	; 232
    10e6:	f0 e0       	ldi	r31, 0x00	; 0
    10e8:	20 81       	ld	r18, Z
    10ea:	22 ff       	sbrs	r18, 2
    10ec:	fd cf       	rjmp	.-6      	; 0x10e8 <_Z15USB_RecvControlPvi+0xc>
//	Will only work for transfers <= 64 bytes
//	TODO
int USB_RecvControl(void* d, int len)
{
	WaitOUT();
	Recv((u8*)d,len);
    10ee:	6c 2f       	mov	r22, r28
    10f0:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <_Z4RecvPVhh>
	return (UEINTX & (1<<RXOUTI)) == 0;
}

static inline void ClearOUT(void)
{
	UEINTX = ~(1<<RXOUTI);
    10f4:	8b ef       	ldi	r24, 0xFB	; 251
    10f6:	80 93 e8 00 	sts	0x00E8, r24
{
	WaitOUT();
	Recv((u8*)d,len);
	ClearOUT();
	return len;
}
    10fa:	8c 2f       	mov	r24, r28
    10fc:	9d 2f       	mov	r25, r29
    10fe:	df 91       	pop	r29
    1100:	cf 91       	pop	r28
    1102:	08 95       	ret

00001104 <_Z14SendInterfacesv>:

int SendInterfaces()
{
    1104:	cf 93       	push	r28
    1106:	df 93       	push	r29
    1108:	1f 92       	push	r1
    110a:	cd b7       	in	r28, 0x3d	; 61
    110c:	de b7       	in	r29, 0x3e	; 62
	int total = 0;
	u8 interfaces = 0;
    110e:	19 82       	std	Y+1, r1	; 0x01

#ifdef CDC_ENABLED
	total = CDC_GetInterface(&interfaces);
    1110:	ce 01       	movw	r24, r28
    1112:	01 96       	adiw	r24, 0x01	; 1
    1114:	0e 94 af 01 	call	0x35e	; 0x35e <_Z16CDC_GetInterfacePh>
#endif

#ifdef HID_ENABLED
	total += HID_GetInterface(&interfaces);
    1118:	ce 01       	movw	r24, r28
    111a:	01 96       	adiw	r24, 0x01	; 1
    111c:	0e 94 0b 04 	call	0x816	; 0x816 <_Z16HID_GetInterfacePh>
#endif

	return interfaces;
    1120:	89 81       	ldd	r24, Y+1	; 0x01
}
    1122:	90 e0       	ldi	r25, 0x00	; 0
    1124:	0f 90       	pop	r0
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	08 95       	ret

0000112c <__vector_11>:
	return true;
}

//	Endpoint 0 interrupt
ISR(USB_COM_vect)
{
    112c:	1f 92       	push	r1
    112e:	0f 92       	push	r0
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	0f 92       	push	r0
    1134:	11 24       	eor	r1, r1
    1136:	ef 92       	push	r14
    1138:	ff 92       	push	r15
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	2f 93       	push	r18
    1140:	3f 93       	push	r19
    1142:	4f 93       	push	r20
    1144:	5f 93       	push	r21
    1146:	6f 93       	push	r22
    1148:	7f 93       	push	r23
    114a:	8f 93       	push	r24
    114c:	9f 93       	push	r25
    114e:	af 93       	push	r26
    1150:	bf 93       	push	r27
    1152:	ef 93       	push	r30
    1154:	ff 93       	push	r31
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	cd b7       	in	r28, 0x3d	; 61
    115c:	de b7       	in	r29, 0x3e	; 62
    115e:	61 97       	sbiw	r28, 0x11	; 17
    1160:	de bf       	out	0x3e, r29	; 62
    1162:	cd bf       	out	0x3d, r28	; 61
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    1164:	10 92 e9 00 	sts	0x00E9, r1
	return UEBCLX;
}

static inline u8 ReceivedSetupInt()
{
	return UEINTX & (1<<RXSTPI);
    1168:	80 91 e8 00 	lds	r24, 0x00E8

//	Endpoint 0 interrupt
ISR(USB_COM_vect)
{
    SetEP(0);
	if (!ReceivedSetupInt())
    116c:	83 ff       	sbrs	r24, 3
    116e:	0b c1       	rjmp	.+534    	; 0x1386 <__vector_11+0x25a>
		return;

	Setup setup;
	Recv((u8*)&setup,8);
    1170:	68 e0       	ldi	r22, 0x08	; 8
    1172:	ce 01       	movw	r24, r28
    1174:	0a 96       	adiw	r24, 0x0a	; 10
    1176:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <_Z4RecvPVhh>
	return UEINTX & (1<<RXSTPI);
}

static inline void ClearSetupInt()
{
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
    117a:	82 ef       	ldi	r24, 0xF2	; 242
    117c:	80 93 e8 00 	sts	0x00E8, r24

	Setup setup;
	Recv((u8*)&setup,8);
	ClearSetupInt();

	u8 requestType = setup.bmRequestType;
    1180:	9a 85       	ldd	r25, Y+10	; 0x0a
	if (requestType & REQUEST_DEVICETOHOST)
    1182:	99 23       	and	r25, r25
    1184:	34 f4       	brge	.+12     	; 0x1192 <__vector_11+0x66>

volatile u8 _usbConfiguration = 0;

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)))
    1186:	e8 ee       	ldi	r30, 0xE8	; 232
    1188:	f0 e0       	ldi	r31, 0x00	; 0
    118a:	80 81       	ld	r24, Z
    118c:	80 ff       	sbrs	r24, 0
    118e:	fd cf       	rjmp	.-6      	; 0x118a <__vector_11+0x5e>
    1190:	03 c0       	rjmp	.+6      	; 0x1198 <__vector_11+0x6c>
		;
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    1192:	8e ef       	ldi	r24, 0xFE	; 254
    1194:	80 93 e8 00 	sts	0x00E8, r24
		WaitIN();
	else
		ClearIN();

    bool ok = true;
	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
    1198:	89 2f       	mov	r24, r25
    119a:	80 76       	andi	r24, 0x60	; 96
    119c:	09 f0       	breq	.+2      	; 0x11a0 <__vector_11+0x74>
    119e:	d4 c0       	rjmp	.+424    	; 0x1348 <__vector_11+0x21c>
	{
		//	Standard Requests
		u8 r = setup.bRequest;
    11a0:	8b 85       	ldd	r24, Y+11	; 0x0b
		if (GET_STATUS == r)
    11a2:	81 11       	cpse	r24, r1
    11a4:	05 c0       	rjmp	.+10     	; 0x11b0 <__vector_11+0x84>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
    11a6:	e1 ef       	ldi	r30, 0xF1	; 241
    11a8:	f0 e0       	ldi	r31, 0x00	; 0
    11aa:	10 82       	st	Z, r1
    11ac:	10 82       	st	Z, r1
    11ae:	e4 c0       	rjmp	.+456    	; 0x1378 <__vector_11+0x24c>
		if (GET_STATUS == r)
		{
			Send8(0);		// TODO
			Send8(0);
		}
		else if (CLEAR_FEATURE == r)
    11b0:	28 2f       	mov	r18, r24
    11b2:	2d 7f       	andi	r18, 0xFD	; 253
    11b4:	21 30       	cpi	r18, 0x01	; 1
    11b6:	09 f4       	brne	.+2      	; 0x11ba <__vector_11+0x8e>
    11b8:	df c0       	rjmp	.+446    	; 0x1378 <__vector_11+0x24c>
		{
		}
		else if (SET_FEATURE == r)
		{
		}
		else if (SET_ADDRESS == r)
    11ba:	85 30       	cpi	r24, 0x05	; 5
    11bc:	51 f4       	brne	.+20     	; 0x11d2 <__vector_11+0xa6>

volatile u8 _usbConfiguration = 0;

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)))
    11be:	e8 ee       	ldi	r30, 0xE8	; 232
    11c0:	f0 e0       	ldi	r31, 0x00	; 0
    11c2:	80 81       	ld	r24, Z
    11c4:	80 ff       	sbrs	r24, 0
    11c6:	fd cf       	rjmp	.-6      	; 0x11c2 <__vector_11+0x96>
		{
		}
		else if (SET_ADDRESS == r)
		{
			WaitIN();
			UDADDR = setup.wValueL | (1<<ADDEN);
    11c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    11ca:	80 68       	ori	r24, 0x80	; 128
    11cc:	80 93 e3 00 	sts	0x00E3, r24
    11d0:	d3 c0       	rjmp	.+422    	; 0x1378 <__vector_11+0x24c>
		}
		else if (GET_DESCRIPTOR == r)
    11d2:	86 30       	cpi	r24, 0x06	; 6
    11d4:	09 f0       	breq	.+2      	; 0x11d8 <__vector_11+0xac>
    11d6:	83 c0       	rjmp	.+262    	; 0x12de <__vector_11+0x1b2>
u8 _cdcComposite = 0;

static
bool SendDescriptor(Setup& setup)
{
	u8 t = setup.wValueH;
    11d8:	1d 85       	ldd	r17, Y+13	; 0x0d
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
    11da:	12 30       	cpi	r17, 0x02	; 2
    11dc:	81 f5       	brne	.+96     	; 0x123e <__vector_11+0x112>
		return SendConfiguration(setup.wLength);
    11de:	e8 88       	ldd	r14, Y+16	; 0x10
    11e0:	f9 88       	ldd	r15, Y+17	; 0x11
//	TODO
static
bool SendConfiguration(int maxlen)
{
	//	Count and measure interfaces
	InitControl(0);	
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	0e 94 31 08 	call	0x1062	; 0x1062 <_Z11InitControli>
	int interfaces = SendInterfaces();
    11ea:	0e 94 82 08 	call	0x1104	; 0x1104 <_Z14SendInterfacesv>
	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
    11ee:	99 e0       	ldi	r25, 0x09	; 9
    11f0:	8e 01       	movw	r16, r28
    11f2:	0f 5f       	subi	r16, 0xFF	; 255
    11f4:	1f 4f       	sbci	r17, 0xFF	; 255
    11f6:	d8 01       	movw	r26, r16
    11f8:	e9 2f       	mov	r30, r25
    11fa:	1d 92       	st	X+, r1
    11fc:	ea 95       	dec	r30
    11fe:	e9 f7       	brne	.-6      	; 0x11fa <__vector_11+0xce>
    1200:	99 83       	std	Y+1, r25	; 0x01
    1202:	92 e0       	ldi	r25, 0x02	; 2
    1204:	9a 83       	std	Y+2, r25	; 0x02
    1206:	91 e0       	ldi	r25, 0x01	; 1
    1208:	9e 83       	std	Y+6, r25	; 0x06
    120a:	90 e8       	ldi	r25, 0x80	; 128
    120c:	98 87       	std	Y+8, r25	; 0x08
    120e:	9a ef       	ldi	r25, 0xFA	; 250
    1210:	99 87       	std	Y+9, r25	; 0x09
    1212:	20 91 47 02 	lds	r18, 0x0247
    1216:	30 91 48 02 	lds	r19, 0x0248
    121a:	27 5f       	subi	r18, 0xF7	; 247
    121c:	3f 4f       	sbci	r19, 0xFF	; 255
    121e:	3c 83       	std	Y+4, r19	; 0x04
    1220:	2b 83       	std	Y+3, r18	; 0x03
    1222:	8d 83       	std	Y+5, r24	; 0x05

	//	Now send them
	InitControl(maxlen);
    1224:	c7 01       	movw	r24, r14
    1226:	0e 94 31 08 	call	0x1062	; 0x1062 <_Z11InitControli>
	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
    122a:	49 e0       	ldi	r20, 0x09	; 9
    122c:	50 e0       	ldi	r21, 0x00	; 0
    122e:	b8 01       	movw	r22, r16
    1230:	80 e0       	ldi	r24, 0x00	; 0
    1232:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z15USB_SendControlhPKvi>
	SendInterfaces();
    1236:	0e 94 82 08 	call	0x1104	; 0x1104 <_Z14SendInterfacesv>
static
bool SendDescriptor(Setup& setup)
{
	u8 t = setup.wValueH;
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
		return SendConfiguration(setup.wLength);
    123a:	21 e0       	ldi	r18, 0x01	; 1
    123c:	9b c0       	rjmp	.+310    	; 0x1374 <__vector_11+0x248>

	InitControl(setup.wLength);
    123e:	88 89       	ldd	r24, Y+16	; 0x10
    1240:	99 89       	ldd	r25, Y+17	; 0x11
    1242:	0e 94 31 08 	call	0x1062	; 0x1062 <_Z11InitControli>
#ifdef HID_ENABLED
	if (HID_REPORT_DESCRIPTOR_TYPE == t)
    1246:	12 32       	cpi	r17, 0x22	; 34
    1248:	51 f4       	brne	.+20     	; 0x125e <__vector_11+0x132>
		return HID_GetDescriptor(t);
    124a:	82 e2       	ldi	r24, 0x22	; 34
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	0e 94 17 04 	call	0x82e	; 0x82e <_Z17HID_GetDescriptori>
    1252:	21 e0       	ldi	r18, 0x01	; 1
    1254:	89 2b       	or	r24, r25
    1256:	09 f0       	breq	.+2      	; 0x125a <__vector_11+0x12e>
    1258:	8d c0       	rjmp	.+282    	; 0x1374 <__vector_11+0x248>
    125a:	20 e0       	ldi	r18, 0x00	; 0
    125c:	8b c0       	rjmp	.+278    	; 0x1374 <__vector_11+0x248>
#endif

	const u8* desc_addr = 0;
	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
    125e:	11 30       	cpi	r17, 0x01	; 1
    1260:	89 f4       	brne	.+34     	; 0x1284 <__vector_11+0x158>
	{
		if (setup.wLength == 8)
    1262:	88 89       	ldd	r24, Y+16	; 0x10
    1264:	99 89       	ldd	r25, Y+17	; 0x11
    1266:	08 97       	sbiw	r24, 0x08	; 8
    1268:	31 f4       	brne	.+12     	; 0x1276 <__vector_11+0x14a>
			_cdcComposite = 1;
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	80 93 44 02 	sts	0x0244, r24
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
    1270:	61 ef       	ldi	r22, 0xF1	; 241
    1272:	71 e0       	ldi	r23, 0x01	; 1
    1274:	23 c0       	rjmp	.+70     	; 0x12bc <__vector_11+0x190>
    1276:	80 91 44 02 	lds	r24, 0x0244
    127a:	81 11       	cpse	r24, r1
    127c:	1a c0       	rjmp	.+52     	; 0x12b2 <__vector_11+0x186>
    127e:	63 e0       	ldi	r22, 0x03	; 3
    1280:	72 e0       	ldi	r23, 0x02	; 2
    1282:	1c c0       	rjmp	.+56     	; 0x12bc <__vector_11+0x190>
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    1284:	13 30       	cpi	r17, 0x03	; 3
    1286:	29 f5       	brne	.+74     	; 0x12d2 <__vector_11+0x1a6>
	{
		if (setup.wValueL == 0) {
    1288:	8c 85       	ldd	r24, Y+12	; 0x0c
    128a:	88 23       	and	r24, r24
    128c:	a9 f0       	breq	.+42     	; 0x12b8 <__vector_11+0x18c>
			desc_addr = (const u8*)&STRING_LANGUAGE;
		}
		else if (setup.wValueL == IPRODUCT) {
    128e:	82 30       	cpi	r24, 0x02	; 2
    1290:	39 f4       	brne	.+14     	; 0x12a0 <__vector_11+0x174>
			return USB_SendStringDescriptor(STRING_PRODUCT, strlen(USB_PRODUCT));
    1292:	6c e0       	ldi	r22, 0x0C	; 12
    1294:	8e e1       	ldi	r24, 0x1E	; 30
    1296:	92 e0       	ldi	r25, 0x02	; 2
    1298:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZL24USB_SendStringDescriptorPKhh>
    129c:	28 2f       	mov	r18, r24
    129e:	6a c0       	rjmp	.+212    	; 0x1374 <__vector_11+0x248>
		}
		else if (setup.wValueL == IMANUFACTURER) {
    12a0:	81 30       	cpi	r24, 0x01	; 1
    12a2:	c9 f4       	brne	.+50     	; 0x12d6 <__vector_11+0x1aa>
			return USB_SendStringDescriptor(STRING_MANUFACTURER, strlen(USB_MANUFACTURER));
    12a4:	68 e0       	ldi	r22, 0x08	; 8
    12a6:	85 e1       	ldi	r24, 0x15	; 21
    12a8:	92 e0       	ldi	r25, 0x02	; 2
    12aa:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZL24USB_SendStringDescriptorPKhh>
    12ae:	28 2f       	mov	r18, r24
    12b0:	61 c0       	rjmp	.+194    	; 0x1374 <__vector_11+0x248>
	const u8* desc_addr = 0;
	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
	{
		if (setup.wLength == 8)
			_cdcComposite = 1;
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
    12b2:	61 ef       	ldi	r22, 0xF1	; 241
    12b4:	71 e0       	ldi	r23, 0x01	; 1
    12b6:	02 c0       	rjmp	.+4      	; 0x12bc <__vector_11+0x190>
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
	{
		if (setup.wValueL == 0) {
			desc_addr = (const u8*)&STRING_LANGUAGE;
    12b8:	6b e2       	ldi	r22, 0x2B	; 43
    12ba:	72 e0       	ldi	r23, 0x02	; 2
		}
		else
			return false;
	}

	if (desc_addr == 0)
    12bc:	61 15       	cp	r22, r1
    12be:	71 05       	cpc	r23, r1
    12c0:	61 f0       	breq	.+24     	; 0x12da <__vector_11+0x1ae>
		return false;
	u8 desc_length = pgm_read_byte(desc_addr);
    12c2:	fb 01       	movw	r30, r22
    12c4:	44 91       	lpm	r20, Z

	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
    12c6:	50 e0       	ldi	r21, 0x00	; 0
    12c8:	80 e8       	ldi	r24, 0x80	; 128
    12ca:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z15USB_SendControlhPKvi>
	return true;
    12ce:	21 e0       	ldi	r18, 0x01	; 1
    12d0:	51 c0       	rjmp	.+162    	; 0x1374 <__vector_11+0x248>
		else
			return false;
	}

	if (desc_addr == 0)
		return false;
    12d2:	20 e0       	ldi	r18, 0x00	; 0
    12d4:	4f c0       	rjmp	.+158    	; 0x1374 <__vector_11+0x248>
		}
		else if (setup.wValueL == IMANUFACTURER) {
			return USB_SendStringDescriptor(STRING_MANUFACTURER, strlen(USB_MANUFACTURER));
		}
		else
			return false;
    12d6:	20 e0       	ldi	r18, 0x00	; 0
    12d8:	4d c0       	rjmp	.+154    	; 0x1374 <__vector_11+0x248>
	}

	if (desc_addr == 0)
		return false;
    12da:	20 e0       	ldi	r18, 0x00	; 0
    12dc:	4b c0       	rjmp	.+150    	; 0x1374 <__vector_11+0x248>
		}
		else if (GET_DESCRIPTOR == r)
		{
			ok = SendDescriptor(setup);
		}
		else if (SET_DESCRIPTOR == r)
    12de:	87 30       	cpi	r24, 0x07	; 7
    12e0:	09 f4       	brne	.+2      	; 0x12e4 <__vector_11+0x1b8>
    12e2:	4e c0       	rjmp	.+156    	; 0x1380 <__vector_11+0x254>
		{
			ok = false;
		}
		else if (GET_CONFIGURATION == r)
    12e4:	88 30       	cpi	r24, 0x08	; 8
    12e6:	21 f4       	brne	.+8      	; 0x12f0 <__vector_11+0x1c4>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
    12e8:	81 e0       	ldi	r24, 0x01	; 1
    12ea:	80 93 f1 00 	sts	0x00F1, r24
    12ee:	44 c0       	rjmp	.+136    	; 0x1378 <__vector_11+0x24c>
		}
		else if (GET_CONFIGURATION == r)
		{
			Send8(1);
		}
		else if (SET_CONFIGURATION == r)
    12f0:	89 30       	cpi	r24, 0x09	; 9
    12f2:	09 f0       	breq	.+2      	; 0x12f6 <__vector_11+0x1ca>
    12f4:	41 c0       	rjmp	.+130    	; 0x1378 <__vector_11+0x24c>
		{
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
    12f6:	93 70       	andi	r25, 0x03	; 3
    12f8:	09 f0       	breq	.+2      	; 0x12fc <__vector_11+0x1d0>
    12fa:	42 c0       	rjmp	.+132    	; 0x1380 <__vector_11+0x254>
    12fc:	ed ee       	ldi	r30, 0xED	; 237
    12fe:	f1 e0       	ldi	r31, 0x01	; 1
    1300:	61 e0       	ldi	r22, 0x01	; 1
static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
    1302:	49 ee       	ldi	r20, 0xE9	; 233
    1304:	50 e0       	ldi	r21, 0x00	; 0
		UECONX = 1;
    1306:	2b ee       	ldi	r18, 0xEB	; 235
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	01 e0       	ldi	r16, 0x01	; 1
		UECFG0X = pgm_read_byte(_initEndpoints+i);
    130c:	8c ee       	ldi	r24, 0xEC	; 236
    130e:	90 e0       	ldi	r25, 0x00	; 0
		UECFG1X = EP_DOUBLE_64;
    1310:	0f 2e       	mov	r0, r31
    1312:	fd ee       	ldi	r31, 0xED	; 237
    1314:	ef 2e       	mov	r14, r31
    1316:	f1 2c       	mov	r15, r1
    1318:	f0 2d       	mov	r31, r0
    131a:	16 e3       	ldi	r17, 0x36	; 54
static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
    131c:	da 01       	movw	r26, r20
    131e:	6c 93       	st	X, r22
		UECONX = 1;
    1320:	d9 01       	movw	r26, r18
    1322:	0c 93       	st	X, r16
		UECFG0X = pgm_read_byte(_initEndpoints+i);
    1324:	74 91       	lpm	r23, Z
    1326:	dc 01       	movw	r26, r24
    1328:	7c 93       	st	X, r23
		UECFG1X = EP_DOUBLE_64;
    132a:	d7 01       	movw	r26, r14
    132c:	1c 93       	st	X, r17
}

static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
    132e:	6f 5f       	subi	r22, 0xFF	; 255
    1330:	31 96       	adiw	r30, 0x01	; 1
    1332:	65 30       	cpi	r22, 0x05	; 5
    1334:	99 f7       	brne	.-26     	; 0x131c <__vector_11+0x1f0>
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
	}
	UERST = 0x7E;	// And reset them
    1336:	ea ee       	ldi	r30, 0xEA	; 234
    1338:	f0 e0       	ldi	r31, 0x00	; 0
    133a:	8e e7       	ldi	r24, 0x7E	; 126
    133c:	80 83       	st	Z, r24
	UERST = 0;
    133e:	10 82       	st	Z, r1
		else if (SET_CONFIGURATION == r)
		{
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
			{
				InitEndpoints();
				_usbConfiguration = setup.wValueL;
    1340:	8c 85       	ldd	r24, Y+12	; 0x0c
    1342:	80 93 49 02 	sts	0x0249, r24
    1346:	18 c0       	rjmp	.+48     	; 0x1378 <__vector_11+0x24c>
		{
		}
	}
	else
	{
		InitControl(setup.wLength);		//	Max length of transfer
    1348:	88 89       	ldd	r24, Y+16	; 0x10
    134a:	99 89       	ldd	r25, Y+17	; 0x11
    134c:	0e 94 31 08 	call	0x1062	; 0x1062 <_Z11InitControli>

//	Handle CLASS_INTERFACE requests
static
bool ClassInterfaceRequest(Setup& setup)
{
	u8 i = setup.wIndex;
    1350:	8e 85       	ldd	r24, Y+14	; 0x0e

#ifdef CDC_ENABLED
	if (CDC_ACM_INTERFACE == i)
    1352:	81 11       	cpse	r24, r1
    1354:	06 c0       	rjmp	.+12     	; 0x1362 <__vector_11+0x236>
		return CDC_Setup(setup);
    1356:	ce 01       	movw	r24, r28
    1358:	0a 96       	adiw	r24, 0x0a	; 10
    135a:	0e 94 bb 01 	call	0x376	; 0x376 <_Z9CDC_SetupR5Setup>
    135e:	28 2f       	mov	r18, r24
    1360:	09 c0       	rjmp	.+18     	; 0x1374 <__vector_11+0x248>
#endif

#ifdef HID_ENABLED
	if (HID_INTERFACE == i)
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	31 f4       	brne	.+12     	; 0x1372 <__vector_11+0x246>
		return HID_Setup(setup);
    1366:	ce 01       	movw	r24, r28
    1368:	0a 96       	adiw	r24, 0x0a	; 10
    136a:	0e 94 40 04 	call	0x880	; 0x880 <_Z9HID_SetupR5Setup>
    136e:	28 2f       	mov	r18, r24
    1370:	01 c0       	rjmp	.+2      	; 0x1374 <__vector_11+0x248>
#endif
	return false;
    1372:	20 e0       	ldi	r18, 0x00	; 0
	{
		InitControl(setup.wLength);		//	Max length of transfer
		ok = ClassInterfaceRequest(setup);
	}

	if (ok)
    1374:	22 23       	and	r18, r18
    1376:	21 f0       	breq	.+8      	; 0x1380 <__vector_11+0x254>
		;
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    1378:	8e ef       	ldi	r24, 0xFE	; 254
    137a:	80 93 e8 00 	sts	0x00E8, r24
    137e:	03 c0       	rjmp	.+6      	; 0x1386 <__vector_11+0x25a>
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
}

static inline void Stall()
{
	UECONX = (1<<STALLRQ) | (1<<EPEN);
    1380:	81 e2       	ldi	r24, 0x21	; 33
    1382:	80 93 eb 00 	sts	0x00EB, r24
		ClearIN();
	else
	{
		Stall();
	}
}
    1386:	61 96       	adiw	r28, 0x11	; 17
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	f8 94       	cli
    138c:	de bf       	out	0x3e, r29	; 62
    138e:	0f be       	out	0x3f, r0	; 63
    1390:	cd bf       	out	0x3d, r28	; 61
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	ff 91       	pop	r31
    1398:	ef 91       	pop	r30
    139a:	bf 91       	pop	r27
    139c:	af 91       	pop	r26
    139e:	9f 91       	pop	r25
    13a0:	8f 91       	pop	r24
    13a2:	7f 91       	pop	r23
    13a4:	6f 91       	pop	r22
    13a6:	5f 91       	pop	r21
    13a8:	4f 91       	pop	r20
    13aa:	3f 91       	pop	r19
    13ac:	2f 91       	pop	r18
    13ae:	1f 91       	pop	r17
    13b0:	0f 91       	pop	r16
    13b2:	ff 90       	pop	r15
    13b4:	ef 90       	pop	r14
    13b6:	0f 90       	pop	r0
    13b8:	0f be       	out	0x3f, r0	; 63
    13ba:	0f 90       	pop	r0
    13bc:	1f 90       	pop	r1
    13be:	18 95       	reti

000013c0 <_Z9USB_Flushh>:
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    13c0:	80 93 e9 00 	sts	0x00E9, r24
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
    13c4:	80 91 f2 00 	lds	r24, 0x00F2
}

void USB_Flush(u8 ep)
{
	SetEP(ep);
	if (FifoByteCount())
    13c8:	88 23       	and	r24, r24
    13ca:	19 f0       	breq	.+6      	; 0x13d2 <_Z9USB_Flushh+0x12>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
    13cc:	8a e3       	ldi	r24, 0x3A	; 58
    13ce:	80 93 e8 00 	sts	0x00E8, r24
    13d2:	08 95       	ret

000013d4 <__vector_10>:
		ReleaseTX();
}

//	General interrupt
ISR(USB_GEN_vect)
{
    13d4:	1f 92       	push	r1
    13d6:	0f 92       	push	r0
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	0f 92       	push	r0
    13dc:	11 24       	eor	r1, r1
    13de:	2f 93       	push	r18
    13e0:	3f 93       	push	r19
    13e2:	4f 93       	push	r20
    13e4:	5f 93       	push	r21
    13e6:	6f 93       	push	r22
    13e8:	7f 93       	push	r23
    13ea:	8f 93       	push	r24
    13ec:	9f 93       	push	r25
    13ee:	af 93       	push	r26
    13f0:	bf 93       	push	r27
    13f2:	ef 93       	push	r30
    13f4:	ff 93       	push	r31
	u8 udint = UDINT;
    13f6:	e1 ee       	ldi	r30, 0xE1	; 225
    13f8:	f0 e0       	ldi	r31, 0x00	; 0
    13fa:	80 81       	ld	r24, Z
	UDINT = 0;
    13fc:	10 82       	st	Z, r1

	//	End of Reset
	if (udint & (1<<EORSTI))
    13fe:	83 ff       	sbrs	r24, 3
    1400:	0f c0       	rjmp	.+30     	; 0x1420 <__vector_10+0x4c>
#define EP_DOUBLE_64 0x36	// Other endpoints

static
void InitEP(u8 index, u8 type, u8 size)
{
	UENUM = index;
    1402:	10 92 e9 00 	sts	0x00E9, r1
	UECONX = 1;
    1406:	91 e0       	ldi	r25, 0x01	; 1
    1408:	90 93 eb 00 	sts	0x00EB, r25
	UECFG0X = type;
    140c:	10 92 ec 00 	sts	0x00EC, r1
	UECFG1X = size;
    1410:	92 e3       	ldi	r25, 0x32	; 50
    1412:	90 93 ed 00 	sts	0x00ED, r25

	//	End of Reset
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
		_usbConfiguration = 0;			// not configured yet
    1416:	10 92 49 02 	sts	0x0249, r1
		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
    141a:	98 e0       	ldi	r25, 0x08	; 8
    141c:	90 93 f0 00 	sts	0x00F0, r25
	}

	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
	if (udint & (1<<SOFI))
    1420:	82 ff       	sbrs	r24, 2
    1422:	1b c0       	rjmp	.+54     	; 0x145a <__vector_10+0x86>
	{
#ifdef CDC_ENABLED
		USB_Flush(CDC_TX);				// Send a tx frame if found
    1424:	83 e0       	ldi	r24, 0x03	; 3
    1426:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <_Z9USB_Flushh>
#endif
		
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
    142a:	80 91 4b 02 	lds	r24, 0x024B
    142e:	88 23       	and	r24, r24
    1430:	41 f0       	breq	.+16     	; 0x1442 <__vector_10+0x6e>
    1432:	80 91 4b 02 	lds	r24, 0x024B
    1436:	81 50       	subi	r24, 0x01	; 1
    1438:	80 93 4b 02 	sts	0x024B, r24
    143c:	81 11       	cpse	r24, r1
    143e:	01 c0       	rjmp	.+2      	; 0x1442 <__vector_10+0x6e>
			TXLED0;
    1440:	5d 9a       	sbi	0x0b, 5	; 11
		if (RxLEDPulse && !(--RxLEDPulse))
    1442:	80 91 4a 02 	lds	r24, 0x024A
    1446:	88 23       	and	r24, r24
    1448:	41 f0       	breq	.+16     	; 0x145a <__vector_10+0x86>
    144a:	80 91 4a 02 	lds	r24, 0x024A
    144e:	81 50       	subi	r24, 0x01	; 1
    1450:	80 93 4a 02 	sts	0x024A, r24
    1454:	81 11       	cpse	r24, r1
    1456:	01 c0       	rjmp	.+2      	; 0x145a <__vector_10+0x86>
			RXLED0;
    1458:	28 9a       	sbi	0x05, 0	; 5
	}
}
    145a:	ff 91       	pop	r31
    145c:	ef 91       	pop	r30
    145e:	bf 91       	pop	r27
    1460:	af 91       	pop	r26
    1462:	9f 91       	pop	r25
    1464:	8f 91       	pop	r24
    1466:	7f 91       	pop	r23
    1468:	6f 91       	pop	r22
    146a:	5f 91       	pop	r21
    146c:	4f 91       	pop	r20
    146e:	3f 91       	pop	r19
    1470:	2f 91       	pop	r18
    1472:	0f 90       	pop	r0
    1474:	0f be       	out	0x3f, r0	; 63
    1476:	0f 90       	pop	r0
    1478:	1f 90       	pop	r1
    147a:	18 95       	reti

0000147c <__vector_1>:
		intFunc[EXTERNAL_INT_4]();
}

#elif defined(EICRA) && defined(EICRB)

ISR(INT0_vect) {
    147c:	1f 92       	push	r1
    147e:	0f 92       	push	r0
    1480:	0f b6       	in	r0, 0x3f	; 63
    1482:	0f 92       	push	r0
    1484:	11 24       	eor	r1, r1
    1486:	2f 93       	push	r18
    1488:	3f 93       	push	r19
    148a:	4f 93       	push	r20
    148c:	5f 93       	push	r21
    148e:	6f 93       	push	r22
    1490:	7f 93       	push	r23
    1492:	8f 93       	push	r24
    1494:	9f 93       	push	r25
    1496:	af 93       	push	r26
    1498:	bf 93       	push	r27
    149a:	ef 93       	push	r30
    149c:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_2])
    149e:	80 91 50 02 	lds	r24, 0x0250
    14a2:	90 91 51 02 	lds	r25, 0x0251
    14a6:	89 2b       	or	r24, r25
    14a8:	29 f0       	breq	.+10     	; 0x14b4 <__vector_1+0x38>
    intFunc[EXTERNAL_INT_2]();
    14aa:	e0 91 50 02 	lds	r30, 0x0250
    14ae:	f0 91 51 02 	lds	r31, 0x0251
    14b2:	09 95       	icall
}
    14b4:	ff 91       	pop	r31
    14b6:	ef 91       	pop	r30
    14b8:	bf 91       	pop	r27
    14ba:	af 91       	pop	r26
    14bc:	9f 91       	pop	r25
    14be:	8f 91       	pop	r24
    14c0:	7f 91       	pop	r23
    14c2:	6f 91       	pop	r22
    14c4:	5f 91       	pop	r21
    14c6:	4f 91       	pop	r20
    14c8:	3f 91       	pop	r19
    14ca:	2f 91       	pop	r18
    14cc:	0f 90       	pop	r0
    14ce:	0f be       	out	0x3f, r0	; 63
    14d0:	0f 90       	pop	r0
    14d2:	1f 90       	pop	r1
    14d4:	18 95       	reti

000014d6 <__vector_2>:

ISR(INT1_vect) {
    14d6:	1f 92       	push	r1
    14d8:	0f 92       	push	r0
    14da:	0f b6       	in	r0, 0x3f	; 63
    14dc:	0f 92       	push	r0
    14de:	11 24       	eor	r1, r1
    14e0:	2f 93       	push	r18
    14e2:	3f 93       	push	r19
    14e4:	4f 93       	push	r20
    14e6:	5f 93       	push	r21
    14e8:	6f 93       	push	r22
    14ea:	7f 93       	push	r23
    14ec:	8f 93       	push	r24
    14ee:	9f 93       	push	r25
    14f0:	af 93       	push	r26
    14f2:	bf 93       	push	r27
    14f4:	ef 93       	push	r30
    14f6:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_3])
    14f8:	80 91 52 02 	lds	r24, 0x0252
    14fc:	90 91 53 02 	lds	r25, 0x0253
    1500:	89 2b       	or	r24, r25
    1502:	29 f0       	breq	.+10     	; 0x150e <__vector_2+0x38>
    intFunc[EXTERNAL_INT_3]();
    1504:	e0 91 52 02 	lds	r30, 0x0252
    1508:	f0 91 53 02 	lds	r31, 0x0253
    150c:	09 95       	icall
}
    150e:	ff 91       	pop	r31
    1510:	ef 91       	pop	r30
    1512:	bf 91       	pop	r27
    1514:	af 91       	pop	r26
    1516:	9f 91       	pop	r25
    1518:	8f 91       	pop	r24
    151a:	7f 91       	pop	r23
    151c:	6f 91       	pop	r22
    151e:	5f 91       	pop	r21
    1520:	4f 91       	pop	r20
    1522:	3f 91       	pop	r19
    1524:	2f 91       	pop	r18
    1526:	0f 90       	pop	r0
    1528:	0f be       	out	0x3f, r0	; 63
    152a:	0f 90       	pop	r0
    152c:	1f 90       	pop	r1
    152e:	18 95       	reti

00001530 <__vector_3>:

ISR(INT2_vect) {
    1530:	1f 92       	push	r1
    1532:	0f 92       	push	r0
    1534:	0f b6       	in	r0, 0x3f	; 63
    1536:	0f 92       	push	r0
    1538:	11 24       	eor	r1, r1
    153a:	2f 93       	push	r18
    153c:	3f 93       	push	r19
    153e:	4f 93       	push	r20
    1540:	5f 93       	push	r21
    1542:	6f 93       	push	r22
    1544:	7f 93       	push	r23
    1546:	8f 93       	push	r24
    1548:	9f 93       	push	r25
    154a:	af 93       	push	r26
    154c:	bf 93       	push	r27
    154e:	ef 93       	push	r30
    1550:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_4])
    1552:	80 91 54 02 	lds	r24, 0x0254
    1556:	90 91 55 02 	lds	r25, 0x0255
    155a:	89 2b       	or	r24, r25
    155c:	29 f0       	breq	.+10     	; 0x1568 <__vector_3+0x38>
    intFunc[EXTERNAL_INT_4]();
    155e:	e0 91 54 02 	lds	r30, 0x0254
    1562:	f0 91 55 02 	lds	r31, 0x0255
    1566:	09 95       	icall
}
    1568:	ff 91       	pop	r31
    156a:	ef 91       	pop	r30
    156c:	bf 91       	pop	r27
    156e:	af 91       	pop	r26
    1570:	9f 91       	pop	r25
    1572:	8f 91       	pop	r24
    1574:	7f 91       	pop	r23
    1576:	6f 91       	pop	r22
    1578:	5f 91       	pop	r21
    157a:	4f 91       	pop	r20
    157c:	3f 91       	pop	r19
    157e:	2f 91       	pop	r18
    1580:	0f 90       	pop	r0
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	0f 90       	pop	r0
    1586:	1f 90       	pop	r1
    1588:	18 95       	reti

0000158a <__vector_4>:

ISR(INT3_vect) {
    158a:	1f 92       	push	r1
    158c:	0f 92       	push	r0
    158e:	0f b6       	in	r0, 0x3f	; 63
    1590:	0f 92       	push	r0
    1592:	11 24       	eor	r1, r1
    1594:	2f 93       	push	r18
    1596:	3f 93       	push	r19
    1598:	4f 93       	push	r20
    159a:	5f 93       	push	r21
    159c:	6f 93       	push	r22
    159e:	7f 93       	push	r23
    15a0:	8f 93       	push	r24
    15a2:	9f 93       	push	r25
    15a4:	af 93       	push	r26
    15a6:	bf 93       	push	r27
    15a8:	ef 93       	push	r30
    15aa:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_5])
    15ac:	80 91 56 02 	lds	r24, 0x0256
    15b0:	90 91 57 02 	lds	r25, 0x0257
    15b4:	89 2b       	or	r24, r25
    15b6:	29 f0       	breq	.+10     	; 0x15c2 <__vector_4+0x38>
    intFunc[EXTERNAL_INT_5]();
    15b8:	e0 91 56 02 	lds	r30, 0x0256
    15bc:	f0 91 57 02 	lds	r31, 0x0257
    15c0:	09 95       	icall
}
    15c2:	ff 91       	pop	r31
    15c4:	ef 91       	pop	r30
    15c6:	bf 91       	pop	r27
    15c8:	af 91       	pop	r26
    15ca:	9f 91       	pop	r25
    15cc:	8f 91       	pop	r24
    15ce:	7f 91       	pop	r23
    15d0:	6f 91       	pop	r22
    15d2:	5f 91       	pop	r21
    15d4:	4f 91       	pop	r20
    15d6:	3f 91       	pop	r19
    15d8:	2f 91       	pop	r18
    15da:	0f 90       	pop	r0
    15dc:	0f be       	out	0x3f, r0	; 63
    15de:	0f 90       	pop	r0
    15e0:	1f 90       	pop	r1
    15e2:	18 95       	reti

000015e4 <__vector_7>:
ISR(INT5_vect) {
  if(intFunc[EXTERNAL_INT_1])
    intFunc[EXTERNAL_INT_1]();
}

ISR(INT6_vect) {
    15e4:	1f 92       	push	r1
    15e6:	0f 92       	push	r0
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	0f 92       	push	r0
    15ec:	11 24       	eor	r1, r1
    15ee:	2f 93       	push	r18
    15f0:	3f 93       	push	r19
    15f2:	4f 93       	push	r20
    15f4:	5f 93       	push	r21
    15f6:	6f 93       	push	r22
    15f8:	7f 93       	push	r23
    15fa:	8f 93       	push	r24
    15fc:	9f 93       	push	r25
    15fe:	af 93       	push	r26
    1600:	bf 93       	push	r27
    1602:	ef 93       	push	r30
    1604:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_6])
    1606:	80 91 58 02 	lds	r24, 0x0258
    160a:	90 91 59 02 	lds	r25, 0x0259
    160e:	89 2b       	or	r24, r25
    1610:	29 f0       	breq	.+10     	; 0x161c <__vector_7+0x38>
    intFunc[EXTERNAL_INT_6]();
    1612:	e0 91 58 02 	lds	r30, 0x0258
    1616:	f0 91 59 02 	lds	r31, 0x0259
    161a:	09 95       	icall
}
    161c:	ff 91       	pop	r31
    161e:	ef 91       	pop	r30
    1620:	bf 91       	pop	r27
    1622:	af 91       	pop	r26
    1624:	9f 91       	pop	r25
    1626:	8f 91       	pop	r24
    1628:	7f 91       	pop	r23
    162a:	6f 91       	pop	r22
    162c:	5f 91       	pop	r21
    162e:	4f 91       	pop	r20
    1630:	3f 91       	pop	r19
    1632:	2f 91       	pop	r18
    1634:	0f 90       	pop	r0
    1636:	0f be       	out	0x3f, r0	; 63
    1638:	0f 90       	pop	r0
    163a:	1f 90       	pop	r1
    163c:	18 95       	reti

0000163e <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    163e:	1f 92       	push	r1
    1640:	0f 92       	push	r0
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	0f 92       	push	r0
    1646:	11 24       	eor	r1, r1
    1648:	cf 92       	push	r12
    164a:	df 92       	push	r13
    164c:	ef 92       	push	r14
    164e:	ff 92       	push	r15
    1650:	2f 93       	push	r18
    1652:	3f 93       	push	r19
    1654:	4f 93       	push	r20
    1656:	5f 93       	push	r21
    1658:	6f 93       	push	r22
    165a:	7f 93       	push	r23
    165c:	8f 93       	push	r24
    165e:	9f 93       	push	r25
    1660:	af 93       	push	r26
    1662:	bf 93       	push	r27
    1664:	cf 93       	push	r28
    1666:	ef 93       	push	r30
    1668:	ff 93       	push	r31
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    166a:	c0 90 51 02 	lds	r12, 0x0251
    166e:	d0 90 52 02 	lds	r13, 0x0252
    1672:	e0 90 53 02 	lds	r14, 0x0253
    1676:	f0 90 54 02 	lds	r15, 0x0254
	unsigned char f = timer0_fract;
    167a:	c0 91 50 02 	lds	r28, 0x0250

	m += MILLIS_INC;
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	70 e4       	ldi	r23, 0x40	; 64
    1682:	80 e0       	ldi	r24, 0x00	; 0
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	20 e0       	ldi	r18, 0x00	; 0
    1688:	30 e0       	ldi	r19, 0x00	; 0
    168a:	a9 01       	movw	r20, r18
    168c:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
    1690:	ca 01       	movw	r24, r20
    1692:	b9 01       	movw	r22, r18
    1694:	c2 0e       	add	r12, r18
    1696:	d3 1e       	adc	r13, r19
    1698:	e4 1e       	adc	r14, r20
    169a:	f5 1e       	adc	r15, r21
	f += FRACT_INC;
    169c:	28 ee       	ldi	r18, 0xE8	; 232
    169e:	33 e0       	ldi	r19, 0x03	; 3
    16a0:	40 e0       	ldi	r20, 0x00	; 0
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
    16a8:	dc 01       	movw	r26, r24
    16aa:	cb 01       	movw	r24, r22
    16ac:	68 94       	set
    16ae:	12 f8       	bld	r1, 2
    16b0:	b6 95       	lsr	r27
    16b2:	a7 95       	ror	r26
    16b4:	97 95       	ror	r25
    16b6:	87 95       	ror	r24
    16b8:	16 94       	lsr	r1
    16ba:	d1 f7       	brne	.-12     	; 0x16b0 <__vector_23+0x72>
    16bc:	8c 0f       	add	r24, r28
	if (f >= FRACT_MAX) {
    16be:	8d 37       	cpi	r24, 0x7D	; 125
    16c0:	30 f0       	brcs	.+12     	; 0x16ce <__vector_23+0x90>
		f -= FRACT_MAX;
    16c2:	8d 57       	subi	r24, 0x7D	; 125
		m += 1;
    16c4:	9f ef       	ldi	r25, 0xFF	; 255
    16c6:	c9 1a       	sub	r12, r25
    16c8:	d9 0a       	sbc	r13, r25
    16ca:	e9 0a       	sbc	r14, r25
    16cc:	f9 0a       	sbc	r15, r25
	}

	timer0_fract = f;
    16ce:	80 93 50 02 	sts	0x0250, r24
	timer0_millis = m;
    16d2:	c0 92 51 02 	sts	0x0251, r12
    16d6:	d0 92 52 02 	sts	0x0252, r13
    16da:	e0 92 53 02 	sts	0x0253, r14
    16de:	f0 92 54 02 	sts	0x0254, r15
	timer0_overflow_count++;
    16e2:	80 91 55 02 	lds	r24, 0x0255
    16e6:	90 91 56 02 	lds	r25, 0x0256
    16ea:	a0 91 57 02 	lds	r26, 0x0257
    16ee:	b0 91 58 02 	lds	r27, 0x0258
    16f2:	01 96       	adiw	r24, 0x01	; 1
    16f4:	a1 1d       	adc	r26, r1
    16f6:	b1 1d       	adc	r27, r1
    16f8:	80 93 55 02 	sts	0x0255, r24
    16fc:	90 93 56 02 	sts	0x0256, r25
    1700:	a0 93 57 02 	sts	0x0257, r26
    1704:	b0 93 58 02 	sts	0x0258, r27
}
    1708:	ff 91       	pop	r31
    170a:	ef 91       	pop	r30
    170c:	cf 91       	pop	r28
    170e:	bf 91       	pop	r27
    1710:	af 91       	pop	r26
    1712:	9f 91       	pop	r25
    1714:	8f 91       	pop	r24
    1716:	7f 91       	pop	r23
    1718:	6f 91       	pop	r22
    171a:	5f 91       	pop	r21
    171c:	4f 91       	pop	r20
    171e:	3f 91       	pop	r19
    1720:	2f 91       	pop	r18
    1722:	ff 90       	pop	r15
    1724:	ef 90       	pop	r14
    1726:	df 90       	pop	r13
    1728:	cf 90       	pop	r12
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63
    172e:	0f 90       	pop	r0
    1730:	1f 90       	pop	r1
    1732:	18 95       	reti

00001734 <micros>:
	SREG = oldSREG;

	return m;
}

unsigned long micros() {
    1734:	cf 92       	push	r12
    1736:	df 92       	push	r13
    1738:	ef 92       	push	r14
    173a:	ff 92       	push	r15
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    173c:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    173e:	f8 94       	cli
	m = timer0_overflow_count;
    1740:	80 91 55 02 	lds	r24, 0x0255
    1744:	90 91 56 02 	lds	r25, 0x0256
    1748:	a0 91 57 02 	lds	r26, 0x0257
    174c:	b0 91 58 02 	lds	r27, 0x0258
#if defined(TCNT0)
	t = TCNT0;
    1750:	26 b5       	in	r18, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    1752:	a8 9b       	sbis	0x15, 0	; 21
    1754:	05 c0       	rjmp	.+10     	; 0x1760 <micros+0x2c>
    1756:	2f 3f       	cpi	r18, 0xFF	; 255
    1758:	19 f0       	breq	.+6      	; 0x1760 <micros+0x2c>
		m++;
    175a:	01 96       	adiw	r24, 0x01	; 1
    175c:	a1 1d       	adc	r26, r1
    175e:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    1760:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    1762:	cc 24       	eor	r12, r12
    1764:	d8 2e       	mov	r13, r24
    1766:	e9 2e       	mov	r14, r25
    1768:	fa 2e       	mov	r15, r26
    176a:	c2 0e       	add	r12, r18
    176c:	d1 1c       	adc	r13, r1
    176e:	e1 1c       	adc	r14, r1
    1770:	f1 1c       	adc	r15, r1
    1772:	60 e4       	ldi	r22, 0x40	; 64
    1774:	70 e0       	ldi	r23, 0x00	; 0
    1776:	80 e0       	ldi	r24, 0x00	; 0
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	20 e0       	ldi	r18, 0x00	; 0
    177c:	30 e0       	ldi	r19, 0x00	; 0
    177e:	a9 01       	movw	r20, r18
    1780:	0e 94 97 0c 	call	0x192e	; 0x192e <__udivmodsi4>
    1784:	ca 01       	movw	r24, r20
    1786:	b9 01       	movw	r22, r18
    1788:	a7 01       	movw	r20, r14
    178a:	96 01       	movw	r18, r12
    178c:	0e 94 87 0c 	call	0x190e	; 0x190e <__mulsi3>
}
    1790:	ff 90       	pop	r15
    1792:	ef 90       	pop	r14
    1794:	df 90       	pop	r13
    1796:	cf 90       	pop	r12
    1798:	08 95       	ret

0000179a <delay>:

void delay(unsigned long ms)
{
    179a:	cf 92       	push	r12
    179c:	df 92       	push	r13
    179e:	ef 92       	push	r14
    17a0:	ff 92       	push	r15
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
    17a6:	6b 01       	movw	r12, r22
    17a8:	7c 01       	movw	r14, r24
	uint16_t start = (uint16_t)micros();
    17aa:	0e 94 9a 0b 	call	0x1734	; 0x1734 <micros>
    17ae:	eb 01       	movw	r28, r22

	while (ms > 0) {
    17b0:	c1 14       	cp	r12, r1
    17b2:	d1 04       	cpc	r13, r1
    17b4:	e1 04       	cpc	r14, r1
    17b6:	f1 04       	cpc	r15, r1
    17b8:	a9 f0       	breq	.+42     	; 0x17e4 <delay+0x4a>
		yield();
    17ba:	0e 94 4b 05 	call	0xa96	; 0xa96 <yield>
		if (((uint16_t)micros() - start) >= 1000) {
    17be:	0e 94 9a 0b 	call	0x1734	; 0x1734 <micros>
    17c2:	6c 1b       	sub	r22, r28
    17c4:	7d 0b       	sbc	r23, r29
    17c6:	68 3e       	cpi	r22, 0xE8	; 232
    17c8:	73 40       	sbci	r23, 0x03	; 3
    17ca:	38 f0       	brcs	.+14     	; 0x17da <delay+0x40>
			ms--;
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	c8 1a       	sub	r12, r24
    17d0:	d1 08       	sbc	r13, r1
    17d2:	e1 08       	sbc	r14, r1
    17d4:	f1 08       	sbc	r15, r1
			start += 1000;
    17d6:	c8 51       	subi	r28, 0x18	; 24
    17d8:	dc 4f       	sbci	r29, 0xFC	; 252

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
    17da:	c1 14       	cp	r12, r1
    17dc:	d1 04       	cpc	r13, r1
    17de:	e1 04       	cpc	r14, r1
    17e0:	f1 04       	cpc	r15, r1
    17e2:	59 f7       	brne	.-42     	; 0x17ba <delay+0x20>
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    17e4:	df 91       	pop	r29
    17e6:	cf 91       	pop	r28
    17e8:	ff 90       	pop	r15
    17ea:	ef 90       	pop	r14
    17ec:	df 90       	pop	r13
    17ee:	cf 90       	pop	r12
    17f0:	08 95       	ret

000017f2 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    17f2:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    17f4:	84 b5       	in	r24, 0x24	; 36
    17f6:	82 60       	ori	r24, 0x02	; 2
    17f8:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    17fa:	84 b5       	in	r24, 0x24	; 36
    17fc:	81 60       	ori	r24, 0x01	; 1
    17fe:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    1800:	85 b5       	in	r24, 0x25	; 37
    1802:	82 60       	ori	r24, 0x02	; 2
    1804:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    1806:	85 b5       	in	r24, 0x25	; 37
    1808:	81 60       	ori	r24, 0x01	; 1
    180a:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    180c:	ee e6       	ldi	r30, 0x6E	; 110
    180e:	f0 e0       	ldi	r31, 0x00	; 0
    1810:	80 81       	ld	r24, Z
    1812:	81 60       	ori	r24, 0x01	; 1
    1814:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    1816:	e1 e8       	ldi	r30, 0x81	; 129
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    181c:	80 81       	ld	r24, Z
    181e:	82 60       	ori	r24, 0x02	; 2
    1820:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    1822:	e0 e8       	ldi	r30, 0x80	; 128
    1824:	f0 e0       	ldi	r31, 0x00	; 0
    1826:	80 81       	ld	r24, Z
    1828:	81 60       	ori	r24, 0x01	; 1
    182a:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    182c:	e1 e9       	ldi	r30, 0x91	; 145
    182e:	f0 e0       	ldi	r31, 0x00	; 0
    1830:	80 81       	ld	r24, Z
    1832:	82 60       	ori	r24, 0x02	; 2
    1834:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    1836:	80 81       	ld	r24, Z
    1838:	81 60       	ori	r24, 0x01	; 1
    183a:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    183c:	e0 e9       	ldi	r30, 0x90	; 144
    183e:	f0 e0       	ldi	r31, 0x00	; 0
    1840:	80 81       	ld	r24, Z
    1842:	81 60       	ori	r24, 0x01	; 1
    1844:	80 83       	st	Z, r24
#endif

#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
    1846:	e1 ec       	ldi	r30, 0xC1	; 193
    1848:	f0 e0       	ldi	r31, 0x00	; 0
    184a:	80 81       	ld	r24, Z
    184c:	84 60       	ori	r24, 0x04	; 4
    184e:	80 83       	st	Z, r24
	sbi(TCCR4B, CS41);
    1850:	80 81       	ld	r24, Z
    1852:	82 60       	ori	r24, 0x02	; 2
    1854:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    1856:	80 81       	ld	r24, Z
    1858:	81 60       	ori	r24, 0x01	; 1
    185a:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
    185c:	e3 ec       	ldi	r30, 0xC3	; 195
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	81 60       	ori	r24, 0x01	; 1
    1864:	80 83       	st	Z, r24
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
    1866:	e0 ec       	ldi	r30, 0xC0	; 192
    1868:	f0 e0       	ldi	r31, 0x00	; 0
    186a:	80 81       	ld	r24, Z
    186c:	82 60       	ori	r24, 0x02	; 2
    186e:	80 83       	st	Z, r24
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
    1870:	e2 ec       	ldi	r30, 0xC2	; 194
    1872:	f0 e0       	ldi	r31, 0x00	; 0
    1874:	80 81       	ld	r24, Z
    1876:	81 60       	ori	r24, 0x01	; 1
    1878:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    187a:	ea e7       	ldi	r30, 0x7A	; 122
    187c:	f0 e0       	ldi	r31, 0x00	; 0
    187e:	80 81       	ld	r24, Z
    1880:	84 60       	ori	r24, 0x04	; 4
    1882:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    1884:	80 81       	ld	r24, Z
    1886:	82 60       	ori	r24, 0x02	; 2
    1888:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    188a:	80 81       	ld	r24, Z
    188c:	81 60       	ori	r24, 0x01	; 1
    188e:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    1890:	80 81       	ld	r24, Z
    1892:	80 68       	ori	r24, 0x80	; 128
    1894:	80 83       	st	Z, r24
    1896:	08 95       	ret

00001898 <main>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1898:	81 e1       	ldi	r24, 0x11	; 17
    189a:	9a e7       	ldi	r25, 0x7A	; 122
    189c:	01 97       	sbiw	r24, 0x01	; 1
    189e:	f1 f7       	brne	.-4      	; 0x189c <main+0x4>
    18a0:	00 c0       	rjmp	.+0      	; 0x18a2 <main+0xa>
    18a2:	00 00       	nop
int main(void)
{
	
	_delay_ms(1000);
	
	init();
    18a4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <init>
	
	
	RCCTRL=1;
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	80 93 67 00 	sts	0x0067, r24
    18ae:	e1 e1       	ldi	r30, 0x11	; 17
    18b0:	fa e7       	ldi	r31, 0x7A	; 122
    18b2:	31 97       	sbiw	r30, 0x01	; 1
    18b4:	f1 f7       	brne	.-4      	; 0x18b2 <main+0x1a>
    18b6:	00 c0       	rjmp	.+0      	; 0x18b8 <main+0x20>
    18b8:	00 00       	nop
        "out __SREG__, __tmp_reg__"
        : /* no outputs */
        : "d" (__tmp),
          "M" (_SFR_MEM_ADDR(CLKPR)),
          "d" (__x)
        : "r0");
    18ba:	93 e0       	ldi	r25, 0x03	; 3
    18bc:	80 e8       	ldi	r24, 0x80	; 128
    18be:	0f b6       	in	r0, 0x3f	; 63
    18c0:	f8 94       	cli
    18c2:	80 93 61 00 	sts	0x0061, r24
    18c6:	90 93 61 00 	sts	0x0061, r25
    18ca:	0f be       	out	0x3f, r0	; 63
    18cc:	81 e1       	ldi	r24, 0x11	; 17
    18ce:	9a e7       	ldi	r25, 0x7A	; 122
    18d0:	01 97       	sbiw	r24, 0x01	; 1
    18d2:	f1 f7       	brne	.-4      	; 0x18d0 <main+0x38>
    18d4:	00 c0       	rjmp	.+0      	; 0x18d6 <main+0x3e>
    18d6:	00 00       	nop
	
	clock_prescale_set(clock_div_8);
	_delay_ms(1000);
	
	//powerSaving();
	DDRD|=(1<<5);
    18d8:	55 9a       	sbi	0x0a, 5	; 10
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    18da:	26 e0       	ldi	r18, 0x06	; 6
    18dc:	40 eb       	ldi	r20, 0xB0	; 176
    18de:	54 e0       	ldi	r21, 0x04	; 4
    18e0:	60 e0       	ldi	r22, 0x00	; 0
    18e2:	70 e0       	ldi	r23, 0x00	; 0
    18e4:	84 e9       	ldi	r24, 0x94	; 148
    18e6:	91 e0       	ldi	r25, 0x01	; 1
    18e8:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <_ZN14HardwareSerial5beginEmh>
	Serial1.begin(1200);
	Serial1.println("Makey");
    18ec:	6e e3       	ldi	r22, 0x3E	; 62
    18ee:	71 e0       	ldi	r23, 0x01	; 1
    18f0:	84 e9       	ldi	r24, 0x94	; 148
    18f2:	91 e0       	ldi	r25, 0x01	; 1
    18f4:	0e 94 fd 05 	call	0xbfa	; 0xbfa <_ZN5Print7printlnEPKc>
	
	while(1)
    {PORTD^=(1<<5);
    18f8:	90 e2       	ldi	r25, 0x20	; 32
    18fa:	8b b1       	in	r24, 0x0b	; 11
    18fc:	89 27       	eor	r24, r25
    18fe:	8b b9       	out	0x0b, r24	; 11
    1900:	e1 e1       	ldi	r30, 0x11	; 17
    1902:	fa e7       	ldi	r31, 0x7A	; 122
    1904:	31 97       	sbiw	r30, 0x01	; 1
    1906:	f1 f7       	brne	.-4      	; 0x1904 <main+0x6c>
    1908:	00 c0       	rjmp	.+0      	; 0x190a <main+0x72>
    190a:	00 00       	nop
    190c:	f6 cf       	rjmp	.-20     	; 0x18fa <main+0x62>

0000190e <__mulsi3>:
    190e:	db 01       	movw	r26, r22
    1910:	8f 93       	push	r24
    1912:	9f 93       	push	r25
    1914:	0e 94 bf 0c 	call	0x197e	; 0x197e <__muluhisi3>
    1918:	bf 91       	pop	r27
    191a:	af 91       	pop	r26
    191c:	a2 9f       	mul	r26, r18
    191e:	80 0d       	add	r24, r0
    1920:	91 1d       	adc	r25, r1
    1922:	a3 9f       	mul	r26, r19
    1924:	90 0d       	add	r25, r0
    1926:	b2 9f       	mul	r27, r18
    1928:	90 0d       	add	r25, r0
    192a:	11 24       	eor	r1, r1
    192c:	08 95       	ret

0000192e <__udivmodsi4>:
    192e:	a1 e2       	ldi	r26, 0x21	; 33
    1930:	1a 2e       	mov	r1, r26
    1932:	aa 1b       	sub	r26, r26
    1934:	bb 1b       	sub	r27, r27
    1936:	fd 01       	movw	r30, r26
    1938:	0d c0       	rjmp	.+26     	; 0x1954 <__udivmodsi4_ep>

0000193a <__udivmodsi4_loop>:
    193a:	aa 1f       	adc	r26, r26
    193c:	bb 1f       	adc	r27, r27
    193e:	ee 1f       	adc	r30, r30
    1940:	ff 1f       	adc	r31, r31
    1942:	a2 17       	cp	r26, r18
    1944:	b3 07       	cpc	r27, r19
    1946:	e4 07       	cpc	r30, r20
    1948:	f5 07       	cpc	r31, r21
    194a:	20 f0       	brcs	.+8      	; 0x1954 <__udivmodsi4_ep>
    194c:	a2 1b       	sub	r26, r18
    194e:	b3 0b       	sbc	r27, r19
    1950:	e4 0b       	sbc	r30, r20
    1952:	f5 0b       	sbc	r31, r21

00001954 <__udivmodsi4_ep>:
    1954:	66 1f       	adc	r22, r22
    1956:	77 1f       	adc	r23, r23
    1958:	88 1f       	adc	r24, r24
    195a:	99 1f       	adc	r25, r25
    195c:	1a 94       	dec	r1
    195e:	69 f7       	brne	.-38     	; 0x193a <__udivmodsi4_loop>
    1960:	60 95       	com	r22
    1962:	70 95       	com	r23
    1964:	80 95       	com	r24
    1966:	90 95       	com	r25
    1968:	9b 01       	movw	r18, r22
    196a:	ac 01       	movw	r20, r24
    196c:	bd 01       	movw	r22, r26
    196e:	cf 01       	movw	r24, r30
    1970:	08 95       	ret

00001972 <__tablejump2__>:
    1972:	ee 0f       	add	r30, r30
    1974:	ff 1f       	adc	r31, r31

00001976 <__tablejump__>:
    1976:	05 90       	lpm	r0, Z+
    1978:	f4 91       	lpm	r31, Z
    197a:	e0 2d       	mov	r30, r0
    197c:	09 94       	ijmp

0000197e <__muluhisi3>:
    197e:	0e 94 ca 0c 	call	0x1994	; 0x1994 <__umulhisi3>
    1982:	a5 9f       	mul	r26, r21
    1984:	90 0d       	add	r25, r0
    1986:	b4 9f       	mul	r27, r20
    1988:	90 0d       	add	r25, r0
    198a:	a4 9f       	mul	r26, r20
    198c:	80 0d       	add	r24, r0
    198e:	91 1d       	adc	r25, r1
    1990:	11 24       	eor	r1, r1
    1992:	08 95       	ret

00001994 <__umulhisi3>:
    1994:	a2 9f       	mul	r26, r18
    1996:	b0 01       	movw	r22, r0
    1998:	b3 9f       	mul	r27, r19
    199a:	c0 01       	movw	r24, r0
    199c:	a3 9f       	mul	r26, r19
    199e:	70 0d       	add	r23, r0
    19a0:	81 1d       	adc	r24, r1
    19a2:	11 24       	eor	r1, r1
    19a4:	91 1d       	adc	r25, r1
    19a6:	b2 9f       	mul	r27, r18
    19a8:	70 0d       	add	r23, r0
    19aa:	81 1d       	adc	r24, r1
    19ac:	11 24       	eor	r1, r1
    19ae:	91 1d       	adc	r25, r1
    19b0:	08 95       	ret

000019b2 <_exit>:
    19b2:	f8 94       	cli

000019b4 <__stop_program>:
    19b4:	ff cf       	rjmp	.-2      	; 0x19b4 <__stop_program>
